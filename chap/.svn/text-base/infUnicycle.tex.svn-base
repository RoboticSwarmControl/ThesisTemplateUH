% Thesis 

\chapter[Approximate Steering of a Unicycle under Bounded Model Perturbation]{Approximate Steering of a Unicycle under Bounded Model Perturbation}
\label{chap-infUnicycle}

In this chapter we apply the framework of ensemble control theory \cite{Brockett1999,Khaneja2000,Li2006,Li2006b,Li2006a,Li2007,Li2009,Li2011,Ruths2011,Ruths2011a,Beauchard2010,Beauchard2010a} to derive an approximate
%open-loop
steering algorithm for a nonholonomic unicycle in the presence of model perturbation that scales both the forward speed and the turning rate by an unknown but bounded constant. The basic idea, similar to early work on sensorless manipulation \cite{Erdmann1988}, is to maintain the set of all possible configurations of the unicycle and to select inputs that reduce the size of this set and drive it toward some goal configuration. The key insight is that the evolution of this set can be described by a family of control systems that depend continuously on the unknown constant. Ensemble control theory provides conditions under which it is possible to steer this entire family to a neighborhood of the goal configuration with a single open-loop input trajectory. These conditions mimic classical tests of nonlinear controllability like
%Chow's Theorem (e.g., see \cite[Chap. 7]{Murray1994})
the Lie algebra rank condition~\cite{Sussmann1972}
but involve approximations by repeated Lie bracketing that are reminiscent of seminal work on steering nonholonomic systems by Lafferriere and Sussman~\cite{Lafferriere1993}.
\blfootnote{The material in this chapter appeared as \cite{Becker2012} (\copyright~2012~IEEE) and in a preliminary conference version~\cite{Becker2010}.}


\section{Problem Statement}\label{sec:introduction}
%\begin{figure}
%      \centering
%      \begin{overpic}[width=.45\columnwidth]{UnicycleWheelRadEnsCont}
%
%				\put(52,4){$x$ }
%				\put(-5,50){$y$ }
%				\put(70,62){$\theta, \epsilon u_2(t)$ }
%				\put(50,80){$\epsilon u_1(t)$ }
%				\put(32,22){$b$ }
%				\put(71,20){$r\epsilon$ }
%	\end{overpic}
%      \caption{\label{fig:UnicycleWheelRadEnsCont} A differential-drive robot with unicycle kinematics and parameter perturbation that scales the wheel radius by an unknown, bounded constant.}
%   \end{figure}
%Consider Fig \ref{fig:UnicycleWheelRadEnsCont}, 
Consider a single unicycle that rolls without slipping. We describe its configuration by $q=(x,y,\theta)$ and its configuration space by $\Cspace = \R^2 \times \field{S}^1$. The control inputs are the forward speed
%~${u_1\in\R}$
$u_{1}$
and the turning rate
$u_{2}$.
%$u_2\in\R$.
%We define a constraint set $\Uspace\subset\R^{2}$ that is symmetric with respect to the origin and that has affine hull $\R^{2}$.
We restrict $(u_{1},u_{2})\in\Uspace$ for some constraint set $\Uspace\subset\R^{2}$,
%with the standard assumption
where we assume that $\Uspace$ is symmetric with respect to the origin and that the affine hull of $\Uspace$ is $\R^{2}$.
%where we assume that $\Uspace$ is symmetric about the origin and that the affine hull of $\Uspace$ is $\R^{2}$.
Corresponding to these inputs, we define vector fields~$g_1,g_2\colon\Cspace\to{T_q\Cspace}$ by
\[
g_1(q) = \begin{bmatrix} \cos\theta\\ \sin\theta\\ 0 \end{bmatrix}
\qquad\qquad
g_2(q) = \begin{bmatrix}  0\\ 0\\ 1 \end{bmatrix}
\]
and write the kinematics of the unicycle in the standard form
\begin{equation}
\label{eq:one}
\dot{q}(t) = g_1(q(t)) u_1(t) + g_2(q(t)) u_2(t).
\end{equation}
Given $\qstart,\qgoal\in\Cspace$ and $\mu>0$, the approximate steering
problem
%for a single unicycle
is to find open-loop inputs
\[
\left(u_{1}(t),u_{2}(t)\right) \colon [0,T] \to \Uspace
\]
that result in $q(0)=\qstart$ and $\norm{q(T)-\qgoal}\leq\mu$ for free final time $T$, where $\norm{\cdot}$ is a suitable norm on $\Cspace$.
If such inputs always exist then we say that \eqref{eq:one} is {\em approximately controllable}---and indeed they do, since $g_{1}$, $g_{2}$, and the Lie bracket $[g_{1},g_{2}]$ span the tangent space $T_{q}\Cspace$ everywhere.


We will solve this same approximate steering problem, but under model perturbation that scales both the forward speed $u_{1}$ and the turning rate $u_{2}$ by some unknown, bounded constant. The resulting kinematics have the form
\begin{equation}
\label{eq:oneuncertain}
\dot{q}(t) = \epsilon\left( g_1(q(t)) u_1(t) + g_2(q(t)) u_2(t) \right),
\end{equation}
where $\epsilon \in [1-\delta, 1+\delta]$ for some $0 \leq \delta < 1$. Rather than try to steer one unicycle governed by \eqref{eq:oneuncertain}---where $\epsilon$ is unknown---our approach is to steer an uncountably infinite collection of unicycles parameterized by~$\epsilon$, each one governed by
\begin{equation}
\label{eq:ensemble}
\dot{q}(t,\epsilon) = \epsilon \bigl( g_1\left( q(t,\epsilon) \right) u_1(t) + g_2\left( q(t,\epsilon) \right) u_2(t) \bigr).
\end{equation}



The remainder of this chapter is organized as follows. %We begin in Section \ref{sec:relatedwork} with a brief review of ensemble control theory and other related work. In Section \ref{sec:analysis}, we proceed to show that \eqref{eq:ensemble} is not ensemble controllable but that a reduced subsystem is.
We begin in Section \ref{sec:analysis}, by showing that \eqref{eq:ensemble} is not ensemble controllable but that a reduced subsystem is.

Based on this result, we derive an approximate steering algorithm in Section \ref{sec:algorithm} that brings the unicycle to within an arbitrarily small neighborhood of any given Cartesian position, regardless of $\epsilon$. Finally, in Section~\ref{sec:hardware}, we validate our approach in experiments with a differential-drive robot that has unknown but bounded wheel radius.




%- local strategy (sensor data may be sufficiently noisy or come at a sufficiently low rate to make online system identification impractical while still allowing periodic course corrections---zig-zag is better than straight line, basically); require obstacle avoidance e.g. Laumond, optimal control, and a compelling use case
%- sensorless manipulation (ball on plate); require more general methods of steering, optimal control, and a compelling use case
%- calibration; require a consideration of random disturbances (non-systematic error), and a compelling use case


% POSSIBILITIES
%- WMR is a familiar, well-known system and the demo is convincing and easy to understand
%- we provide a systematic way to reason about tradeoffs (the cost / complexity of a trajectory vs. the resulting uncertainty); can change the nominal inputs (and nominal trajectory) a little bit to suppress uncertainty a little bit
%- says what not to do if you want to calibrate (or what to do, by exaggerating or suppressing dispersion---note that this has potential application even in a differential form, where we exaggerate dispersion locally so that the next measurement gives us more information)
%- possible application to sensorless manipulation, for example to balls rolling on plates
%- the result is pretty surprising
%- it is possible to steer infinite-dimensional systems that have a particular structure using many of the same tools that we have developed in the robotics community in the context of nonholonomic systems; these models may find use in future
%- sensor data may be sufficiently noisy or come at a sufficiently low rate to make online system identification impractical while still allowing periodic course corrections
%- combination of robust feedforward/feedback strategies


%LIMITATIONS
%- calibration (it's not enough to argue about the inevitable presence of calibration error; first, this error will likely be in both wheel size and wheel radius, something for which we cannot compensate; second, common models have this error taking a random walk, i.e., it is time-varying, something that is outside of our current model)~\cite{Borenstein1995,Kelly2004,Thrun2005,Martinelli2007,Antonelli2007}
%- drift (in practice the robots would accumulate drift because inputs are being applied in open-loop; the standard way to compensate for draft is to add sensors / feedback; with feedback, we could either do online calibration and/or apply closed-loop control, again obviating the problem we consider)
%- motion planning (a number of things need to be addressed first; we would need to establish small-time local controllability, a property that may or may not be a ``minor'' extension of what we talk about here; second, to use a subdivision-based approach as suggested by Laumond, it would be necessary to prove that ``the drift that results from successive gaps can be bounded''; etc.)
%- the trajectories we produce may be impractical (feedback control would require no ``detours'')
%- there is a whole literature on robust control, and in particular on ``robust control of perturbed nonholonomic systems'', e.g., \cite{Bennani1995,Lucibello2001} --- the latter allows us to achieve arbitrary configurations, not just Cartesian positions
%- although we require that forward speed and turning rate be scaled by the same factor, this is not required by closed-loop approaches
%- our algorithm takes advantage of lucky things that happen for our chosen system of interest (frankly, this is why we chose it)---for example, the fact that our motion primitives lead to decision variables entering linearly, i.e., it is really easy to solve the steering problem in this case, whereas for other systems, it might be much, much harder even if we can prove ensemble controllability
%

%\section{Related Work}
%\label{sec:relatedwork}





%\subsection{More notes}

%Within the robotics community, our solution approach is most closely related to previous work on sensorless manipulation and preimage planning.
%In this work, the basic idea is to explicitly maintain the set of all possible
%robot configurations and to select a sequence of actions that reduces the size of this set and drives it toward some goal configuration.

%world states (which may include the robot, parts to be manipulated, objects in the environment, etc.) and to select a sequence of actions that reduces the size of this set.

%\subsection{Notes}

%
%The term {\em programmable force field}
%was coined by B{\"o}hringer, Bhatt, and Goldberg in the mid-1990s
%to describe a new class of mechanisms for industrial parts handling
%based on vibratory surfaces.
%These mechanisms, suggested a decade earlier by Singer and Seering~\cite{Singer1987},
%are of two basic types:
%a planar array of micro-scale actuators~\cite{Bohringer1994,Liu1995}
%or
%a single flat plate moving transversely~\cite{Bohringer1995}.
%By varying the amplitude, frequency, and direction of oscillations,
%these mechanisms can
%both position and orient individual parts without sensors.
%A series of papers by the same authors on the vibratory arrays~\cite{Bohringer1994a,Bohringer1997,Bohringer1999,Bohringer2000,Lamiraux2001}
%later spurred similar work using arrays of rolling actuators~\cite{Luntz2001,Murphey2004a}
%and of air sources and sinks~\cite{Moon2004,Moon2006,Varsos2006,Varsos2006a}.
%The single flat plate was extended to 3DOF vibration by Reznik and Canny~\cite{Reznik1998,Reznik2000,Reznik2001},
%then recently to 6DOF vibration by Vose, Umbanhowar, and Lynch~\cite{Vose2007,Vose2008,Umbanhowar2008,Vose2008a}.
%This last work showed that the same programmable force field can be used to manipulate
%multiple parts.
%%more than one part at the same time.
%All of the above are planar mechanisms and, with the exception of the air source/sink arrays,
%all of them require direct physical contact with the objects they manipulate.
%The focus of my work will be on non-planar mechanisms that require no physical contact---such as electromagnetic and acoustic fields, optical and chemical gradients, and fluid flow---and that
%are targeted at applications other than industrial parts handling.
%%My work will also focus on the manipulation of much larger groups of objects.

%Two concepts from the literature on industrial parts handling, and in particular on sensorless manipulation~\cite{Erdmann1988}, have influenced my approach.
%First, sensorless manipulation strategies often use a sequential composition of
%primitive operations, for example ``squeezing'' a part either virtually with a programmable force field or simply between two flat, parallel plates~\cite{Goldberg1993}.
%%at a given angle~\cite{Goldberg1993}.
%These primitive operations make it easier to compute the set of reachable configurations.
%Second, sensorless manipulation strategies often take advantage of limit cycle behavior,
%engineering fixed points and basins of attraction so that parts only exit the feeder when they reach the correct orientation~\cite{Lynch2002,Murphey2004,Murphey2005}.
%These two strategies have also been applied to a much wider array of mechanisms such as vibratory bowls~\cite{Berretty2001,Goemans2006} or assembly lines~\cite{Goldberg1993,Swanson1995,Akella1996,Akella2000,Stappen2002}.
%They have also been extended to situations with uncertainty~\cite{Goldberg1999,Moll2002} and closed-loop feedback~\cite{Akella1999,Murphey2004a}, both of which will be relevant to the proposed work.



\section{Analysis of Controllability}
\label{sec:analysis}

In this section, we will establish controllability results for the system \eqref{eq:ensemble}.
Our method of approach will closely follow the one taken in~\cite{Brockett1999,Khaneja2000,Li2006,Li2006b,Li2006a,Li2007,Li2009,Li2011}. 
% moved to intro
% First, we state formally what it means
%%for a family of control systems
%to be ensemble controllable.
%\begin{definition}
%Consider the family of control systems
%\[
%\dot{q}(t,\epsilon) = f\left(q(t,\epsilon),u(t),t,\epsilon\right),
%\]
%where $q\in \Cspace \subset\R^{n}$, $u\in\Uspace\subset\R^{m}$, $\epsilon\in[1-\delta,1+\delta]$ for $0\leq\delta<1$, and $f$ is a smooth function. This family is \emph{ensemble controllable} on
%the function space
%$L_{2}\left([1-\delta,1+\delta],\Cspace\right)$ if for all $\mu>0$ and continuous $\qstart,\qgoal\in L_{2}\left([1-\delta,1+\delta],\Cspace\right)$ there exists $T>0$ and piecewise-continuous $u\colon[0,T]\to\Uspace$ such that $q(0,\epsilon) = \qstart(\epsilon)$ and $\norm{q(T,\epsilon)-\qgoal(\epsilon)}\leq\mu$ for all $\epsilon\in[1-\delta,1+\delta]$.
%\end{definition}
%
%Note that this definition is a slight generalization of what appeared in Section \ref{sec:introduction}, since we allow $\qstart$ and $\qgoal$ to be arbitrary functions of $\epsilon$. As pointed out by \cite{Beauchard2010}, the reader should interpret being ensemble controllable as being approximately controllable on $L_{2}\left([1-\delta,1+\delta],\Cspace\right)$.


\subsection{Finding a Controllable Subsystem}
\label{sec:notcontrollable}

We begin with a proof by construction of the following negative result, which was originally suggested by \cite{Li2006}.
\begin{theorem}
\label{thm:notcontrollable}
If $\delta>0$, then the system \eqref{eq:ensemble} is not ensemble controllable.
\end{theorem}
\begin{IEEEproof}
Notice that for any $u_{1}$ and $u_{2}$, we have
\[
\dot{\theta}(t,\epsilon) = \epsilon u_{2}(t).
\]
As a consequence, if we define an auxiliary state $\gamma(t)$
% \in S^{1}$
such that $\gamma(0)=0$ and
\[
\dot{\gamma}(t) = u_{2}(t),
\]
then it is clear that
\[
\theta(t,\epsilon) = \theta(0,\epsilon) + \epsilon \gamma(t)
\]
for all~$\epsilon \in [1-\delta,1+\delta]$,
where we assume without loss of generality that we are working in the coordinates of a single local chart on $S^{1}$.
For any $\Delta\theta>0$, choose
\[
\qstart(\epsilon) = \left(x_\text{start}(\epsilon), y_\text{start}(\epsilon), \theta_\text{start}(\epsilon) \right)
\]
and
\[
\qgoal(\epsilon) = \left(x_\text{goal}(\epsilon), y_\text{goal}(\epsilon), \theta_\text{goal}(\epsilon) \right)
\]
satisfying
\[
\theta_\text{goal}(\epsilon)-\theta_\text{start}(\epsilon) = \Delta\theta
\]
for all $\epsilon \in [1-\delta,1+\delta]$, and let
$\mu = \delta \Delta\theta/2$.
We have
\begin{align*}
\norm{q(T,\epsilon)-\qgoal(\epsilon)}
&\geq \norm{\theta(T,\epsilon) - \theta_\text{goal}(\epsilon)} \\
&= \norm{\theta(0,\epsilon) +\epsilon\gamma(T) - \theta_\text{goal}(\epsilon)} \\
&= \norm{\epsilon\gamma(T) - \left(\theta_\text{goal}(\epsilon)-\theta_\text{start}(\epsilon)\right)} \\
&= \norm{\epsilon\gamma(T)-\Delta\theta}.
\end{align*}
%for all $\epsilon \in [1-\delta,1+\delta]$.
Since we have assumed $\delta>0$, then for any $\gamma(T)$ there exists some $\epsilon \in [1-\delta,1+\delta]$ at which
\[
\norm{\epsilon\gamma(T)-\Delta\theta} > \mu,
\]
and so \eqref{eq:ensemble} is not ensemble controllable by definition.

\end{IEEEproof}


This result suggests the construction of a subsystem that, as we will show in the following section, is ensemble controllable.
We write the configuration of this subsystem as
\[
p(t,\epsilon) = \left( x(t,\epsilon), y(t,\epsilon), \gamma(t) \right),
\]
where~$\gamma(t)$ is the auxiliary state we introduced in the proof of Theorem \ref{thm:notcontrollable}.

We have just shown that the evolution of this subsystem is governed by the alternate kinematic model
\begin{equation}
\label{eq:subsystem}
\dot{p}(t,\epsilon) = \epsilon h_1\left( p(t,\epsilon), \epsilon \right) u_1(t) + h_2\left( p(t,\epsilon), \epsilon \right) u_2(t),
\end{equation}
where
\begin{gather}
\label{eq:vectorfields}
\begin{split}
h_1\left(p(t,\epsilon), \epsilon\right) &= \begin{bmatrix} \cos{\left(\theta(0,\epsilon) + \epsilon \gamma(t)\right)}\\ \sin{\left(\theta(0,\epsilon) + \epsilon \gamma(t)\right)}\\ 0 \end{bmatrix} \\
h_2\left(p(t,\epsilon), \epsilon\right) &= \begin{bmatrix}  0\\ 0\\ 1 \end{bmatrix}
\end{split}
\end{gather}
and~$\theta(0,\epsilon)$ is the initial heading given by~$\qstart$, as before.
For convenience, we will abbreviate
\begin{align*}
c(t,\epsilon) &= \cos{\left(\theta(0,\epsilon) + \epsilon \gamma(t)\right)} \\
s(t,\epsilon) &= \sin{\left(\theta(0,\epsilon) + \epsilon \gamma(t)\right)}
\end{align*}
so that
\begin{equation}
\label{eq:h1}
h_{1}\left(p(t,\epsilon), \epsilon\right) = \begin{bmatrix} c(t,\epsilon) \\ s(t,\epsilon) \\ 0 \end{bmatrix}.
\end{equation}
Since there is no longer any functional dependence of $p_{3}(t,\epsilon)$ on $\epsilon$, it is clear that we have removed the feature of \eqref{eq:ensemble} that allowed us to conclude a lack of controllability. We will see that the resulting subsystem \eqref{eq:subsystem} is, in fact, controllable.

Before proceeding, notice that the vector field $h_{1}$ in \eqref{eq:vectorfields} may be expressed
\[
h_{1}\left(p(t,\epsilon),\epsilon\right)
=
R(\epsilon)
\begin{bmatrix}
\cos \left(\epsilon \gamma(t)\right) \\
\sin \left(\epsilon \gamma(t)\right) \\
0
\end{bmatrix}
\]
where
\[
R(\epsilon) = \begin{bmatrix}
\cos \theta(0,\epsilon) & -\sin \theta(0,\epsilon) & 0 \\
\sin \theta(0,\epsilon) & \cos \theta(0,\epsilon) & 0 \\
0 & 0 & 1
\end{bmatrix},
\]
so if we apply the transformation
\[
p^{\prime}(t,\epsilon) = R(\epsilon)^{T} p(t,\epsilon),
\]
then without loss of generality it is always possible to assume that $\theta(0,\epsilon)=0$ for all~$\epsilon$.




\subsection{Controllability By Polynomial Approximation}
\label{sec:controllableInfUnicycle}

%We will now prove the following result: about the reduced subsystem that we derived in the previous section:
We will now prove that the reduced subsystem derived in the previous section is ensemble controllable. We will do this by using repeated bracketing to get higher-order powers of $\epsilon$, and then by using polynomial approximation to construct arbitrary vector flows. This approach is similar to what appears in \cite{Li2009}, and involves computations that are reminiscent of \cite{Lafferriere1993}.
\begin{theorem}
\label{thm:controllable}
The system \eqref{eq:subsystem} is ensemble controllable.
\end{theorem}
\begin{IEEEproof}
Taking Lie brackets, we have
\begin{align*}
[\epsilon h_1,h_2]
&= \epsilon \left( \frac{\partial h_2}{\partial p} h_1 - \frac{\partial h_1}{\partial p} h_2 \right) \\
&= 0-\epsilon \begin{bmatrix} 0 & 0 & -\epsilon s \\ 0 & 0 & \epsilon c \\ 0 & 0 & 0 \end{bmatrix} \begin{bmatrix} 0 \\ 0 \\ 1 \end{bmatrix} \\
&= \epsilon^{2} \begin{bmatrix} s \\ -c \\ 0 \end{bmatrix}
\end{align*}
and
\begin{align*}
[[\epsilon h_1,h_2],h_{2}]
&= 0 - \epsilon^{2} \begin{bmatrix} 0 & 0 & \epsilon c \\ 0 & 0 & \epsilon s \\ 0 & 0 & 0 \end{bmatrix} \begin{bmatrix} 0 \\ 0 \\ 1 \end{bmatrix} \\
&= - \epsilon^{3} \begin{bmatrix} c \\ s \\ 0 \end{bmatrix} \\
&= -\epsilon^{3} h_{1}.
\end{align*}
Let us define
\[
h_{3} = \begin{bmatrix} -s \\ c \\ 0 \end{bmatrix},
\]
so that~$[\epsilon h_{1},h_{2}] = -\epsilon^{2} h_{3}$.
Repeating this process, we can produce control vector fields of the form
$\epsilon^{2i+1}h_{1}$
and
$\epsilon^{2i+2}h_{3}$
for any $i\geq 0$.
Since we have assumed that $\Uspace$ is symmetric and that the affine hull of $\Uspace$ is $\R^{2}$, then with piecewise-constant inputs (i.e., a sufficient number of ``back-and-forth'' maneuvers) we can produce flows of the form
\[
\exp \left( a_{0}\epsilon h_{1} \right)
\dotsm
\exp \left( a_{k-1}\epsilon^{2k-1} h_{1} \right)
=
\exp\left(\sum_{i=0}^{k-1} a_{i}\epsilon^{2i+1}h_{1}\right)
\]
and
\[
\exp \left( b_{0}\epsilon^{2} h_{3} \right)
\dotsm
\exp \left( b_{k-1}\epsilon^{2k} h_{3} \right)
=
\exp\left(\sum_{i=0}^{k-1} b_{i}\epsilon^{2i+2}h_{3}\right)
\]
for freely chosen coefficients $a,b\in\R^{k}$.
Let
\[
\pstart(\epsilon) = \left(\xstart(\epsilon),\ystart(\epsilon),\gammastart\right)
\]
and
\[
\pgoal(\epsilon) = \left(\xgoal(\epsilon),\ygoal(\epsilon),\gammagoal\right)
\]
for any given continuous real-valued functions
\[
\xstart,\ystart,\xgoal,\ygoal\in L_{2}\left([1-\delta,1+\delta],\R\right)
\]
and for any given $\gammastart,\gammagoal\in S^{1}$.
Define
\[
c = \gammagoal-\gammastart
\]
and take
\[
\begin{bmatrix}
\alpha(\epsilon) \\
\beta(\epsilon)
\end{bmatrix}
=
\begin{bmatrix}
\cos c & \sin c \\ -\sin c & \cos c
\end{bmatrix}
\begin{bmatrix}
\xgoal(\epsilon)-\xstart(\epsilon) \\
\ygoal(\epsilon)-\ystart(\epsilon)
\end{bmatrix}
\]
for all $\epsilon\in[1-\delta,1+\delta]$, where continuity of $\alpha$ and $\beta$ follows from continuity of $\xstart, \xgoal, \ystart, \ygoal$.
We can represent the desired change in configuration by the flow
\[
\exp\left(\beta(\epsilon) h_{3}\right)
\exp\left(\alpha(\epsilon) h_{1}\right)
\exp\left(c h_{2}\right).
\]
The Stone-Weierstrass theorem~\cite{Royden1988} tells us that given~$\eta > 0$ and a continuous real function
\[
\nu(\epsilon) \colon [1-\delta,1+\delta] \to \R,
\]
there exists a polynomial function~$\rho(\epsilon)$ such that
\[
\abs{\rho(\epsilon) - \nu(\epsilon)} < \eta
\]
for all~$\epsilon \in [\underline{\epsilon},\overline{\epsilon}]$.
An immediate corollary is that
continuous real functions
on the domain $[\underline{\epsilon},\overline{\epsilon}]=[1-\delta,1+\delta]$ for some ${0\leq\delta<1}$ can be uniformly approximated either by an odd polynomial or by an even polynomial. (This result would not be true on an arbitrary domain, which is why we restrict ${\delta<1}$.) As a consequence,
%there exist polynomials
we can choose $a,b\in\R^{k}$ so that
\begin{align*}
\alpha(\epsilon) &\approx \sum_{i=0}^{k-1} a_{i}\epsilon^{2i+1} \\
\beta(\epsilon) &\approx \sum_{i=0}^{k-1} b_{i}\epsilon^{2i+2}
\end{align*}
for $\epsilon\in[1-\delta,1+\delta]$, with error vanishing in $k$.
%Given $\mu>0$, 
The time complexity of the resulting motion increases with $k$ and with the number of switches required to approximate flows along each
vector field $\epsilon^{2i+1}h_{1}$
and
$\epsilon^{2i+2}h_{3}$, but remains finite for any given $\mu>0$.
%We conclude that \eqref{eq:subsystem} is ensemble controllable.
Our result follows.
\end{IEEEproof}



%%The situation is worse for the ensemble control system~\eqref{eq:ensemble}, where again $m=2$ but $n=\infty$.
%%The key question is if these differential constraints are integrable---in other words, if we are ``stuck'' on an~$m$-dimensional manifold in~$\Cspace$ or if, through a clever sequence of inputs, we can span the entire space.
%%
%%%The key question: is this constraint integrable? I.e., are we stuck on a lower-dimensional manifold, or can we span the entire space through clever application of inputs?




%\subsection{Notes}

%The idea is to synthesize new directions, as in parallel parking.
%The analytical approach is to construct the Lie algebra.
%We do not worry about how bracket directions are implemented.
%The LARC gives us a sufficient condition for controllability of \eqref{eq:one}.
%Unfortunately this condition breaks down for infinite-dimensional systems as in \eqref{eq:ensemble}.
%We look at where brackets come from.
%They represent vectors in tangent space that can be {\em approximated} by cyclic application of controls.
%In the same way, we will try to {\em approximate} any desired tangent vector---in this case, a continuous function of~$\epsilon$---using polynomial approximation in powers of~$\epsilon$.
%We proceed as follows.


%A sufficient condition for controllability is provided by the Lie algebra rank condition.
%, which states that if the Lie algebra generated by~$g_{1},\dotsc,g_{m}$ has 
%spans a space of rank $n$






\section{Approximate Steering Algorithm}
\label{sec:algorithm}

In the previous section, we showed that the subsystem \eqref{eq:subsystem} is ensemble controllable.
Based on this result, we will now derive an approximate steering algorithm for this subsystem.
%The inputs produced by this algorithm will bring our original system of interest \eqref{eq:oneuncertain} to an arbitrarily small neighborhood of any given Cartesian position for all $\epsilon\in[1-\delta,1+\delta]$.
%We will restrict ourselves
Although the boundary conditions given to this algorithm could in general be arbitrary continuous functions $\pstart(\epsilon)$ and $\pgoal(\epsilon)$, for our application of interest---where \eqref{eq:subsystem} captures the range of possible outcomes for a single unicycle---these functions are always constant and have the form
\begin{align*}
p_\text{start}(\epsilon) &= \left(x_\text{start},y_\text{start},\gamma_\text{start}\right) \\
p_\text{goal}(\epsilon) &= \left(x_\text{goal},y_\text{goal},\gamma_\text{goal}\right),
\end{align*}
where we may as well assume that $\gamma_\text{start}=\gamma_\text{goal}=\gamma$. If we apply the transformation
\[
\begin{bmatrix} \Delta x \\ \Delta y \end{bmatrix} = \begin{bmatrix} \cos\gamma & \sin\gamma \\ -\sin\gamma & \cos\gamma \end{bmatrix} \begin{bmatrix} x_\text{goal}-x_\text{start} \\ y_\text{goal}-y_\text{start} \end{bmatrix},
\]
then without loss of generality we may further assume that
\begin{align*}
p_\text{start}(\epsilon) &= \left(0,0,0\right) \\
p_\text{goal}(\epsilon) &= \left(\Delta x, \Delta y, 0\right).
\end{align*}
Finally, we assume that $(1,0)\in\Uspace$ and that $(v,1)\in\Uspace$ for some $v\geq 0$, hence also that $(-1,0),(-v,-1)\in\Uspace$. We make this assumption primarily for convenience.
Scaling either input would require only scaling the corresponding time for which it is applied, and taking the reflection $-\Delta y$ would directly address the case where
%allow us to apply our algorithm directly in the case where
$(v,-1)\in\Uspace$.
However, the fact that it is possible to ``go straight'' is important for the simplicity of our algorithm.
%Since the affine hull of $\Uspace$ is $\R^{2}$, it is always possible to approximate $(u_{1},u_{2})=(1,0)$ by rapid switching
If $(1,0)\notin\Uspace$, then we will assume that the corresponding control vector field is approximated by rapid switching, which is possible because the affine hull of $\Uspace$ is $\R^{2}$. In any case, our model applies unchanged to both a differential-drive robot ($v=0$) and a car-like robot ($v\neq 0$).

\subsection{One Motion Primitive with Piecewise-Constant Inputs}


%For $\phi>0$ and $a,b\in\R$,
Consider the following input
%trajectory
for
%$\phi>0$
$\psi\geq 0$
%is a positive angle
and
$a^{\prime},b^{\prime}\in\R$:
\[
u(t) =
\begin{cases}
(v,1) & 0\leq t < \psi \\
(\sign a^{\prime},0) & \psi\leq t < \psi+\abs{a^{\prime}} \\
(-v,-1) & \psi+\abs{a^{\prime}}\leq t < 3\psi+\abs{a^{\prime}} \\
(\sign b^{\prime},0) & 3\psi+\abs{a^{\prime}} \leq t < 3\psi+\abs{a^{\prime}}+\abs{b^{\prime}} \\
(v,1) & 3\psi+\abs{a^{\prime}}+\abs{b^{\prime}}\leq t < 4\psi+\abs{a^{\prime}}+\abs{b^{\prime}}.
\end{cases}
\]

We call this input a {\em motion primitive}.
%We can think of it as a piecewise-constant approximation to a sinusoid.
% of magnitude~$\phi$.
%It is easy to show by direct calculation that the
If $\gamma(0)=0$, then
the result of applying this motion primitive
is to achieve
%\[
%p(\Delta t,\epsilon) - p(0,\epsilon) =
%\begin{bmatrix}
%( a^{\prime}+b^{\prime} ) \epsilon \cos\left(\epsilon\phi\right) \\
%( a^{\prime}-b^{\prime} ) \epsilon \sin\left(\epsilon\phi\right) \\
%0
%\end{bmatrix}
%\]
%in time
%\[
%\Delta t = 4\phi+\abs{a^{\prime}}+\abs{b^{\prime}}.
%\]
\[
p(\Delta t,\epsilon) - p(0,\epsilon) =
\begin{bmatrix}
( a^{\prime}+b^{\prime} ) \epsilon \cos\left(\epsilon\psi\right) \\
( a^{\prime}-b^{\prime} ) \epsilon \sin\left(\epsilon\psi\right) \\
0
\end{bmatrix}
\]
in time
\[
\Delta t = 4\psi+\abs{a^{\prime}}+\abs{b^{\prime}}.
\]
With the input transformation
\[
a^{\prime} = \frac{a+b}{2}
\qquad\qquad
b^{\prime} = \frac{a-b}{2}
\]
for freely chosen~$a,b\in\R$, we can write this expression as
\[
p(\Delta t,\epsilon) - p(0,\epsilon) =
\begin{bmatrix}
a \epsilon \cos\left(\epsilon\psi\right) \\
b \epsilon \sin\left(\epsilon\psi\right) \\
0
\end{bmatrix}
\]
%and denote the corresponding motion primitive by $(a,b,\psi)$.
%We will use this motion primitive as the basis for our approximate steering algorithm.
We will denote this motion primitive by the triple $(a,b,\psi)$
and use it as the basis for our approximate steering algorithm.

\subsection{Composition of Two Motion Primitives}
\label{sec:twoprimitives}

Because our motion primitives leave $\gamma$ invariant, we are free to concatenate them. For example, consider the sequential application of two primitives $(a_{1},b_{1},\psi_{1})$ and $(a_{2},b_{2},\psi_{2})$. If $\gamma(0)=0$, then the result is to achieve
\[
%\label{eq:exampleresult}
p(\Delta t,\epsilon) - p(0,\epsilon) =
\begin{bmatrix}
a_{1} \epsilon \cos\left(\epsilon\psi_{1}\right) + a_{2} \epsilon \cos\left(\epsilon\psi_{2}\right) \\
b_{1} \epsilon \sin\left(\epsilon\psi_{1}\right) + b_{2} \epsilon \sin\left(\epsilon\psi_{2}\right) \\
0
\end{bmatrix}
\]
in time
\[
\Delta t =
\left(4\psi_{1}+\abs{a_{1}^{\prime}}+\abs{b_{1}^{\prime}}\right)
+
\left(4\psi_{2}+\abs{a_{2}^{\prime}}+\abs{b_{2}^{\prime}}\right),
\]
where
\[
a_{i}^{\prime} = \frac{a_{i}+b_{i}}{2}
\qquad\qquad
b_{i}^{\prime} = \frac{a_{i}-b_{i}}{2}
\]
for $i\in\{1,2\}$.
%, as before.
%\begin{align*}
%\Delta t &= \left(4\psi_{1}+\abs{\frac{a_{1}+b_{1}}{2}}+\abs{\frac{a_{1}-b_{1}}{2}}\right) \\
%&\qquad+\left(4\psi_{2}+\abs{\frac{a_{2}+b_{2}}{2}}+\abs{\frac{a_{2}-b_{2}}{2}}\right).
%\end{align*}
In fact, we can compose these two primitives in a slightly different way that achieves the same result in less time.
Assume that $\psi_{2}>\psi_{1}$.
Consider the following input:
\[
u(t) =
\begin{cases}
(v,1) & \,\,\,\,\,0\leq t < \psi_{1} \\
(\sign a_{1}^{\prime},0) & \dotsm\leq t < \dotsm+\abs{a_{1}^{\prime}} \\
(v,1) & \dotsm\leq t < \dotsm+(\psi_{2}-\psi_{1}) \\
(\sign a_{2}^{\prime},0) & \dotsm\leq t < \dotsm+\abs{a_{2}^{\prime}} \\
(-v,-1) & \dotsm\leq t < \dotsm+(\psi_{2}+\psi_{1}) \\
(\sign b_{1}^{\prime},0) & \dotsm\leq t < \dotsm+\abs{b_{1}^{\prime}} \\
(-v,-1) & \dotsm\leq t < \dotsm+(\psi_{2}-\psi_{1}) \\
(\sign b_{2}^{\prime},0) & \dotsm\leq t < \dotsm+\abs{b_{2}^{\prime}} \\
(v,1) & \dotsm\leq t < \dotsm+\psi_{2}.
\end{cases}
\]
It is easy to verify that $p(\Delta t,\epsilon) - p(0,\epsilon)$ remains the same but that
%this input achieves the same result as before, but in time
\[
\Delta t = \left(\abs{a_{1}^{\prime}}+\abs{b_{1}^{\prime}}\right)
+
\left(4\psi_{2}+\abs{a_{2}^{\prime}}+\abs{b_{2}^{\prime}}\right),
\]
which is lower than before by $4\psi_{1}$. Figure \ref{fig:primitives} shows an example, for which $\psi_{1}=\pi/4$, $\psi_{2}=\pi/2$, and $v=1/2$.



\subsection{Composition of Many Motion Primitives}

We generalize our result of the previous section as follows.
Given $\phi>0$, consider
a sequence of $k+1$ motion primitives
%\[
%\left( a_{j+1}, b_{j}, \psi_{j} \right)
%\]
\[
\left( a_{j+1}, b_{j}, \psi_{j}=j\phi \right)
\]
for $j\in\left\{0,\dotsc,k\right\}$, where
%we define
%\[
%\psi_{j} = j\phi
%\]
%for some $\phi>0$ and
we restrict $a_{k+1}=b_{0}=0$.
We have indexed these primitives so that they are defined by the choice of $a,b\in\R^{k}$, where $a=(a_{1},\dotsc,a_{k})$ and $b=(b_{1},\dotsc,b_{k})$ as usual. We compose these primitives as in Section \ref{sec:twoprimitives}, noting that because $\psi_{0}=0$, the resulting inputs begin with translation and not with rotation. In particular, we have
\begin{equation}
\label{eq:finalinputs}
u(t) =
\begin{cases}
(\sign a_{1}^{\prime},0) & 0\leq t < \abs{a_{1}^{\prime}} \\
(v,1) & \dotsm\leq t < \dotsm+\phi \\
(\sign a_{1}^{\prime},0) & \dotsm\leq t < \dotsm+\abs{a_{2}^{\prime}} \\
\quad\vdots \\
(v,1) & \dotsm\leq t < \dotsm+\phi \\
(\sign a_{k}^{\prime},0) & \dotsm\leq t < \dotsm+\abs{a_{k}^{\prime}} \\
(-v,-1) & \dotsm\leq t < \dotsm+k\phi \\
(\sign b_{1}^{\prime},0) & \dotsm\leq t < \dotsm+\abs{b_{1}^{\prime}} \\
(-v,-1) & \dotsm\leq t < \dotsm+\phi \\
(\sign b_{2}^{\prime},0) & \dotsm\leq t < \dotsm+\abs{b_{2}^{\prime}} \\
\quad\vdots \\
(-v,-1) & \dotsm\leq t < \dotsm+\phi \\
(\sign b_{k}^{\prime},0) & \dotsm\leq t < \dotsm+\abs{b_{k}^{\prime}} \\
(v,1) & \dotsm\leq t < \dotsm+(k-1)\phi.
\end{cases}
\end{equation}
where
\[
a^{\prime} = \frac{1}{2}\left(\begin{bmatrix}a\\0\end{bmatrix} + \begin{bmatrix}0\\b\end{bmatrix}\right) 
\qquad
b^{\prime} = \frac{1}{2}\left(\begin{bmatrix}a\\0\end{bmatrix} - \begin{bmatrix}0\\b\end{bmatrix}\right).
\]
As before, it is easy to verify that
\[
p(\Delta t,\epsilon) - p(0,\epsilon)
=
\begin{bmatrix}
\sum_{j=1}^{k} a_{j}\epsilon\cos\left(\epsilon (j-1)\phi\right) \\
\sum_{j=1}^{k} b_{j}\epsilon\sin\left(\epsilon j\phi\right) \\
0
\end{bmatrix},
\]
where
\begin{equation}
\label{eq:timecost}
\Delta t = 4(k-1) \phi + \sum_{i=1}^{k}\left(\abs{a^{\prime}_{i}}+\abs{b^{\prime}_{i}}\right).
\end{equation}
As in Section~\ref{sec:analysis}, our problem has been reduced to function approximation. Given $\mu>0$ and $(\Delta x,\Delta y)\in\R^{2}$, we need to find $\phi>0$ and $a,b\in\R^{k}$ for sufficiently large $k$ so that
\[
\abs{\Delta x - \sum_{j=1}^{k} a_{j}\epsilon\cos\left(\epsilon (j-1)\phi\right)} \leq \mu
\]
and
\[
\abs{\Delta y - \sum_{j=1}^{k} b_{j}\epsilon\sin\left(\epsilon j\phi\right)} \leq \mu
\]
for all $\epsilon\in[1-\delta,1+\delta]$.
The resulting input \eqref{eq:finalinputs} would then be a solution to the approximate steering problem for \eqref{eq:subsystem}.



\begin{figure}[t]
\centering
\begin{overpic}[width=0.49\columnwidth]{primitive1}
\small
\put(40,0){(a)}
\put(0,25){start}
\put(75,56){finish}
%\put(37,50){$\abs{a_{1}^{\prime}}$}
\put(22,35){$\abs{a_{1}^{\prime}}$}
\put(44,17){$\abs{b_{1}^{\prime}}$}
\put(96,35){$\abs{a_{2}^{\prime}}$}
\put(48,53){$\abs{b_{2}^{\prime}}$}
\end{overpic}
\hfill
\begin{overpic}[width=0.49\columnwidth]{primitive2}
\small
\put(40,0){(b)}
\put(0,25){start}
\put(75,56){finish}
\put(24,37){$\abs{a_{1}^{\prime}}$}
\put(44,35){$\abs{b_{1}^{\prime}}$}
\put(49,82){$\abs{a_{2}^{\prime}}$}
\put(48.5,56){$\abs{b_{2}^{\prime}}$}
\end{overpic}
\caption{
Two different ways to compose motion primitives $(a_{1},b_{1},\psi_{1}=\pi/4)$ and $(a_{2},b_{2},\psi_{2}=\pi/2)$, where $v=1/2$. In (a), they are concatenated. In (b), they are interwoven, with the same result but lower execution time. The concatenation is shown in (b) as a dotted line for comparison.
%In this example, $v=1/2$.
In this figure, we are only showing the nominal path, corresponding to $\epsilon=1$.
}
\label{fig:primitives}
\end{figure}



\subsection{Achieving Error of a Particular Order}
In this section, we construct motion-plans composed of piecewise-constant inputs to achieve tolerances of a particular order in $\epsilon$.  An example path is shown in Fig.~\ref{fig:simTraj}
\begin{figure}[t!]
\centering
\href{http://www.youtube.com/watch?v=FppnS5xcRow}{\begin{overpic}[width=\columnwidth]{simulationresults}
\end{overpic}}
\caption{
An ensemble with $\epsilon \in [0.8,1.2]$ moving a unit distance in the $x$ direction achieving $4$th-order error in $\abs{\epsilon-1}$, which corresponds to a maximum error bound of $0.2^{3}=0.008$.
%, achieving an error tolerance of $e=10^{-4}$.
Thin red lines show
%paths that could be followed
the path followed for particular values of $\epsilon$.
The actual robot follows only one of these paths.
Thick black lines show the entire ensemble at instants of time.\\
\href{http://www.youtube.com/watch?v=FppnS5xcRow}{(Video online: http://www.youtube.com/watch?v=FppnS5xcRow)}
}
\label{fig:simTraj}
\end{figure}

We can express the result
\begin{align*}
\Delta p_{1}(\epsilon) &= p_{1}(\Delta t,\epsilon)-p_{1}(0,\epsilon) \\
\Delta p_{2}(\epsilon) &= p_{2}(\Delta t,\epsilon)-p_{2}(0,\epsilon)
\end{align*}
of applying \eqref{eq:finalinputs} as
Taylor
series
%in $\epsilon$
about $\epsilon=1$:
\begin{align*}
\Delta p_{1}(\epsilon) &= \Delta p_{1}(1) + \left(\frac{\partial \Delta p_{1}}{\partial \epsilon}\biggr\rvert_{\epsilon=1}\right)\left(\epsilon-1\right)+\dotsm \\
\Delta p_{2}(\epsilon) &= \Delta p_{2}(1) + \left(\frac{\partial \Delta p_{2}}{\partial \epsilon}\biggr\rvert_{\epsilon=1}\right)\left(\epsilon-1\right)+\dotsm.
\end{align*}
%\begin{align*}
%\Delta p_{1}(\epsilon) &= \Delta p_{1}(1) + \left(\frac{\partial \Delta p_{1}}{\partial \epsilon}\biggr\rvert_{\epsilon=1}\right)\left(\epsilon-1\right)\\
%&\qquad+\frac{1}{2!}\left(\frac{\partial^{2}\Delta p_{1}}{\partial \epsilon^{2}}\biggr\rvert_{\epsilon=1}\right)\left(\epsilon-1\right)^{2}+\dotsm \\
%\Delta p_{2}(\epsilon) &= \Delta p_{2}(1) + \left(\frac{\partial \Delta p_{2}}{\partial \epsilon}\biggr\rvert_{\epsilon=1}\right)\left(\epsilon-1\right)\\
%&\qquad+\frac{1}{2!}\left(\frac{\partial^{2}\Delta p_{2}}{\partial \epsilon^{2}}\biggr\rvert_{\epsilon=1}\right)\left(\epsilon-1\right)^{2}+\dotsm
%\end{align*}
Each series has the form
\begin{align*}
\Delta p_{1} (\epsilon) &= \sum_{i=1}^{k}r_{i}\left(\epsilon-1\right)^{i-1} + O\left(\abs{\epsilon-1}^{k}\right) \\
\Delta p_{2} (\epsilon) &= \sum_{i=1}^{k}s_{i}\left(\epsilon-1\right)^{i-1} + O\left(\abs{\epsilon-1}^{k}\right),
\end{align*}
where we collect $r=(r_{1},\dotsc,r_{k})$ and $s=(s_{1},\dotsc,s_{k})$ so that $r,s\in\R^{k}$.
Explicit formulas for $r$ and $s$ are given by
\begin{gather}
\label{linearequationsInfUnicycle}
\begin{split}
r &= Aa \\
s &= Bb,
\end{split}
\end{gather}
where the matrices $A,B\in\R^{k\times k}$ have elements
\begin{align*}
A_{ij} &= \frac{1}{\left(i-1\right)!} \left( \frac{\partial^{i-1} \left(\epsilon\cos\left(\epsilon(j-1)\phi\right)\right)}{\partial \epsilon^{i-1}}\biggr\rvert_{\epsilon=1}\right) \\
B_{ij} &= \frac{1}{\left(i-1\right)!} \left( \frac{\partial^{i-1} \left(\epsilon\sin\left(\epsilon j\phi\right)\right)}{\partial \epsilon^{i-1}}\biggr\rvert_{\epsilon=1}\right)
\end{align*}
for all $i,j\in\{1,\dotsc,k\}$. Note that $A$ and $B$ do not depend on $\epsilon$.
To approximate $\Delta x = 1$ and $\Delta y = 1$
%To achieve $\Delta p_{1}=\Delta x$ and $\Delta p_{2}=\Delta y$
with error that is of order $k$ in $\abs{\epsilon-1}$, we require only a solution $a,b$ to the system of linear equations \eqref{linearequationsInfUnicycle} that results in
\begin{align*}
r &= \begin{bmatrix} 1 & 0 & \dotsm & 0 \end{bmatrix}^{T} \\
s &= \begin{bmatrix} 1 & 0 & \dotsm & 0 \end{bmatrix}^{T}.
%r = s = \begin{bmatrix} 1 & 0 & \dotsm & 0 \end{bmatrix}^{T}.
\end{align*}
Both $A$ and $B$ are square matrices, so assuming both are non-singular (and well-conditioned)---which will hold for almost all choices of the angle $\phi$---then
%that defines each motion primitive---then
\eqref{linearequationsInfUnicycle} has a unique solution.
An immediate consequence is that achievable error decreases exponentially in the number $k+1$ of primitives, a result that was shown empirically in~\cite{Becker2010}.  This relationship is highlighted in Fig.~\ref{fig:DiffDriveOrder1}.

\begin{figure}[t!]
\centering
\begin{overpic}[width=0.85\columnwidth]{DiffDriveOrder1}\put(6,40){ $k=1$ } \put(83,1){ $\epsilon$ } \put(64,18){\small\begin{sideways} Distance Error \end{sideways} } \end{overpic}
\begin{overpic}[width=0.85\columnwidth]{DiffDriveOrder2}\put(6,40){ $k=2$ } \put(83,1){ $\epsilon$ } \put(64,18){\small\begin{sideways} Distance Error \end{sideways} } \end{overpic}
\begin{overpic}[width=0.85\columnwidth]{DiffDriveOrder3}\put(6,40){ $k=3$ } \put(83,1){ $\epsilon$ } \put(64,18){\small\begin{sideways} Distance Error \end{sideways} } \end{overpic}
\caption{ \label{fig:DiffDriveOrder1}
An ensemble with $\epsilon \in [0.8,1.2]$ moving a unit distance in the $x$ direction achieving different orders of error in $\abs{\epsilon-1}$. 
%, achieving an error tolerance of $e=10^{-4}$.
Thin red lines show
the path followed for particular values of $\epsilon$.
The actual robot follows only one of these paths.
Thick black lines show the entire ensemble at instants of time. The right column shows the resulting error as a function of $\epsilon$.
}
\end{figure}
\begin{figure}[t!]
\ContinuedFloat 
\centering
\begin{overpic}[width=0.85\columnwidth]{DiffDriveOrder4}\put(6,40){ $k=4$ } \put(83,1){ $\epsilon$ } \put(64,18){\small\begin{sideways} Distance Error \end{sideways} } \end{overpic}
\begin{overpic}[width=0.85\columnwidth]{DiffDriveOrder5}\put(6,40){ $k=5$ } \put(83,1){ $\epsilon$ } \put(64,18){\small\begin{sideways} Distance Error \end{sideways} } \end{overpic}
\caption{ 
(Continued.)
}
\end{figure}


By linearity, if the parameters $a$ and $b$ achieve
\[
\left(\Delta p_{1},\Delta p_{2}\right)=\left(1,1\right),
\]
then the scaled parameters
$a\Delta x$ and $b\Delta y$
%\[
%a\left(x_\text{goal}-x_\text{start}\right)
%\]
achieve
\[
\left(\Delta p_{1},\Delta p_{2}\right)=\left(\Delta x,\Delta y\right)
\]
for arbitrary $\Delta x$ and $\Delta y$.
%it is clear that the scaled parameters $ax_\text{goal}$ and $b\Delta y$ will reach arbitrary $\Delta x$ and $\Delta y$.
%The resulting piecewise-constant inputs are given by
In other words, scaling a single, precomputed maneuver gets you everywhere for free.
Subsequently, we need only compute
\begin{align*}
a^{\prime} &= \frac{1}{2}\left(\begin{bmatrix}a\\0\end{bmatrix} \Delta x + \begin{bmatrix}0\\b\end{bmatrix} \Delta y\right) \\
b^{\prime} &= \frac{1}{2}\left(\begin{bmatrix}a\\0\end{bmatrix} \Delta x - \begin{bmatrix}0\\b\end{bmatrix} \Delta y\right).
\end{align*}


One advantage of this strategy over the one used in~\cite{Becker2010} is that we no longer have to sample $\epsilon$ in order to compute the parameters $a$ and $b$. Doing so had previously introduced approximation error that was difficult to quantify. Now, the series expansion gives us an explicit bound on this error. In particular,
%say we are given $\mu>0$ and $(\Delta x,\Delta y)\in\R^{2}$. 
to achieve a tolerance $\mu>0$, we simply choose any integer $k>0$ that satisfies $\delta^{k-1}<\mu$.




We can also quantify the trade-off between the time cost $\Delta t$
%(in terms of total elapsed time)
and the resulting uncertainty.
% (in terms of error order).
The total elapsed time to reach $\left(\Delta x,\Delta y\right)$ with $k$th-order error in $\abs{\epsilon-1}$ is given by \eqref{eq:timecost}.
%%$1^{T}a^{\prime}+1^{T}b^{\prime}$
%\[
%4 (k-1) \phi + \sum_{i=1}^{k}\left(\abs{a^{\prime}_{i}}+\abs{b^{\prime}_{i}}\right).
%\]
Direct computation verifies that $\abs{a_{i}^{\prime}}$ and $\abs{b_{i}^{\prime}}$ decay rapidly with $i$, so the term $4(k-1)\phi$ dominates the elapsed time. As a consequence, the time cost is $O(k)$.
%We emphasize that this result will weaken if $(1,0)\notin\Uspace$
Note that if switching is required to generate $(u_{1},u_{2})=(1,0)$---i.e., if $(1,0)\notin\Uspace$---this will only scale the cost by a constant factor.
%$(1,0)\notin\Uspace$

Finally, we consider the total distance traveled in the workspace. If $\epsilon=1$, this distance is given by
%Finally, we can compute a bound on the total distance traveled. This distance is
%
%Finally, we can establish a ``weak'' form of small-time local controllability that allows us to avoid obstacles. The distance traveled to reach $\Delta x$ and $\Delta y$ is
\[
d(\Delta x, \Delta y) =
4(k-1)\phi v +
\sum_{i=1}^{k}\left(\abs{a^{\prime}_{i}}+\abs{b^{\prime}_{i}}\right).
\]
We may compute an upper bound on $d$ by solving the following convex optimization problem, which is linear in the decision variables $\Delta x$ and $\Delta y$:
\begin{align*}
\text{minimize}&\qquad d(\Delta x, \Delta y) \\
\text{subject to}&\qquad \abs{\Delta x} \leq 1 \\
&\qquad \abs{\Delta y} \leq 1.
\end{align*}
Call the solution to this problem $d_\text{min}$.
Recall that $\epsilon\in[1-\delta,1+\delta]$ and $0\leq \delta<1$, so the distance traveled for any $\epsilon$ is at most $2d_\text{min}$.
As a corollary, we know that $(x(t,\epsilon),y(t,\epsilon))$ remains always inside a ball of radius $2d_\text{min}$ during the application of our steering algorithm.
This interesting result indicates that it might be possible to prove some form of small-time local controllability as the basis for extending our work from steering to motion planning (e.g., as in \cite{Laumond1987,Laumond1994}), although it is not obvious yet how to proceed.


Figures \ref{fig:algorithm:computeprimitive}-\ref{fig:algorithm:computeinputs} provide pseudo-code that implements our approximate steering algorithm.
We emphasize that this algorithm produces an open-loop input trajectory that neither requires nor takes advantage of sensor feedback.
%We emphasize that for a given $k$, the function \proc{ComputePrimitive} need only be called once.




\begin{figure}[t!]
\centering
\frame{
\hspace{0.025cm}
\begin{minipage}{0.95\columnwidth}
\small

\vspace{2mm}

$\proc{ComputePrimitive}(\phi,k)$

\vspace{2mm}

Given an angle $\phi$ and a non-negative integer $k$, do the following:

\vspace{2mm}

\begin{itemize}

\item Compute the elements of $A,B\in\R^{k \times k}$ according to
\begin{align*}
A_{ij} &= \frac{1}{\left(i-1\right)!} \left( \frac{\partial^{i-1} \left(\epsilon\cos\left(\epsilon(j-1)\phi\right)\right)}{\partial \epsilon^{i-1}}\biggr\rvert_{\epsilon=1}\right) \\
B_{ij} &= \frac{1}{\left(i-1\right)!} \left( \frac{\partial^{i-1} \left(\epsilon\sin\left(\epsilon j\phi\right)\right)}{\partial \epsilon^{i-1}}\biggr\rvert_{\epsilon=1}\right)
\end{align*}
for all $i,j\in\{1,\dotsc,k\}$.

\vspace{2mm}

\item Compute $a,b\in\R^{k}$ according to
\begin{align*}
a &= A^{-1}r \\
b &= B^{-1}s,
\end{align*}
where
\begin{align*}
r &= \begin{bmatrix} 1 & 0 & \dotsm & 0 \end{bmatrix}^{T} \\
s &= \begin{bmatrix} 1 & 0 & \dotsm & 0 \end{bmatrix}^{T}.
\end{align*}

\end{itemize}
\vspace{0.2cm}
Return $(a,b)$.
\vspace{0.2cm}
\normalsize
\end{minipage}
}
\caption{The algorithm that we use to precompute a motion primitive.}
\label{fig:algorithm:computeprimitive}
\end{figure}

\begin{figure}[t!]
\centering
\frame{
\hspace{0.025cm}
\begin{minipage}{\columnwidth}
\small
\vspace{1mm}

$\proc{ComputeInput}(\phi,k,x_\text{start},y_\text{start},x_\text{goal},y_\text{goal},\gamma)$

\vspace{1mm}

Given an angle $\phi$, a non-negative integer $k$, a start configuration $\left(x_\text{start},y_\text{start},\gamma\right)$, and a goal configuration $\left(x_\text{goal},y_\text{goal},\gamma\right)$,
%and a motion primitive defined by $a,b\in\R^{k}$,
do the following:

\vspace{-1mm}

\begin{itemize}

\item Compute the motion primitive
\[
(a,b) = \proc{ComputePrimitive}(\phi,k).
\]

\vspace{-4mm}

\item Compute the desired change in Cartesian position
\[
\begin{bmatrix} \Delta x \\ \Delta y \end{bmatrix} = \begin{bmatrix} \cos\gamma & \sin\gamma \\ -\sin\gamma & \cos\gamma \end{bmatrix} \begin{bmatrix} x_\text{goal}-x_\text{start} \\ y_\text{goal}-y_\text{start} \end{bmatrix}.
\]

\vspace{-4mm}

\item Compute the parameters
\begin{align*}
a^{\prime} &= \frac{1}{2}\left(\begin{bmatrix}a\\0\end{bmatrix} \Delta x + \begin{bmatrix}0\\b\end{bmatrix} \Delta y\right) \\
b^{\prime} &= \frac{1}{2}\left(\begin{bmatrix}a\\0\end{bmatrix} \Delta x - \begin{bmatrix}0\\b\end{bmatrix} \Delta y\right).
\end{align*}

\vspace{-4mm}

\item Compute the piecewise-constant input
\[
u(t) =
\begin{cases}
(\sign a_{1}^{\prime},0) & \,\,\,\, 0\leq t < \abs{a_{1}^{\prime}} \\
(v,1) & \dotsm\leq t < \dotsm+\phi \\
(\sign a_{1}^{\prime},0) & \dotsm\leq t < \dotsm+\abs{a_{2}^{\prime}} \\
\quad\vdots \\
(v,1) & \dotsm\leq t < \dotsm+\phi \\
(\sign a_{k}^{\prime},0) & \dotsm\leq t < \dotsm+\abs{a_{k}^{\prime}} \\
(-v,-1) & \dotsm\leq t < \dotsm+k\phi \\
(\sign b_{1}^{\prime},0) & \dotsm\leq t < \dotsm+\abs{b_{1}^{\prime}} \\
(-v,-1) & \dotsm\leq t < \dotsm+\phi \\
(\sign b_{2}^{\prime},0) & \dotsm\leq t < \dotsm+\abs{b_{2}^{\prime}} \\
\quad\vdots \\
(-v,-1) & \dotsm\leq t < \dotsm+\phi \\
(\sign b_{k}^{\prime},0) & \dotsm\leq t < \dotsm+\abs{b_{k}^{\prime}} \\
(v,1) & \dotsm\leq t < \dotsm+(k-1)\phi.
\end{cases}
\]
\end{itemize}

\vspace{-2mm}

Return $u$.
%$(\upsilon,\tau)$.

\vspace{1mm}

\normalsize
\end{minipage}
}
\caption{
Our approximate steering algorithm. It acts only to scale the primitive generated by the subroutine \proc{ComputePrimitive}, which need only be called once for given $\phi$ and $k$.
We recommend choosing $\phi=\pi/2$ and the smallest integer $k$ such that $\delta^{k-1}<\mu$ for a given tolerance $\mu>0$.
}
\label{fig:algorithm:computeinputs}
\end{figure}

\subsection{Results in Simulation}

Figure~\ref{fig:simTraj} shows the results of applying our approximate steering algorithm to an ensemble control system of the form \eqref{eq:subsystem} for which $\delta = 0.2$ and $\left(\Delta x,\Delta y\right) = (1,0)$.
In this example, we chose $k=4$, so that maximum error is expected to be $O(\delta^{4})$.

Equivalently, we expect that
\begin{align*}
0.008 = \delta^{3} &> \max_{\epsilon\in[1-\delta,1+\delta]} \left\{\Delta p_{1}(\epsilon) - \Delta x\right\} \\
0.008 = \delta^{3} &> \max_{\epsilon\in[1-\delta,1+\delta]} \left\{\Delta p_{2}(\epsilon) - \Delta y\right\}.
\end{align*}


We chose $\phi=\pi/2$.

As a consequence,
the matrices $A$ and $B$ have a very simple form:

\[
A =
\begin{bmatrix}
1 & 0 & -1 & 0 \\
1 & -\pi/2 & -1 & 3\pi/2 \\
0 & -\pi/2 & \pi^{2}/2 & 3\pi/2 \\
0 & \pi^{3}/48 & \pi^{2}/16 & -9\pi^{3}/16
\end{bmatrix}
\]
and
\[
B =
\begin{bmatrix}
1 & 0 & -1 & 0 \\
1 & -\pi & -1 & 2\pi \\
-\pi^{2}/8 & -\pi & 9\pi^{2}/8 & 2\pi \\
-\pi^{2}/8 & \pi^{3}/6 & 9\pi^{2}/8 & -4\pi^{3}/3
\end{bmatrix}.
\]
The linear equations~\eqref{linearequationsInfUnicycle} can be solved exactly to produce
\[
a =
\begin{bmatrix}
1+(2/\pi^{2}) \\
3\left(8+3\pi^{2}\right)/\left(4\pi^{3}\right) \\
2/\pi^{2} \\
\left(24+\pi^{2}\right)/\left(12 \pi^{3}\right)
\end{bmatrix}
\;\;\text{and}\;\;
b =
\begin{bmatrix}
(9/8)+\left(1/\pi^{2}\right) \\
\left(6+4\pi^{2}\right)/\left(3\pi^{3}\right) \\
(1/8) + (1/\pi^{2}) \\
\left(6+\pi^{2}\right)/\left(6\pi^{3}\right)
\end{bmatrix}.
\]
We also compute exactly the bound on total distance traveled, in this case achieved when $(\Delta x,\Delta y)=(-1,-1)$:
\[
d_\text{min} = \frac{9}{4}+\frac{6+\pi  (8+3 \pi )}{2 \pi ^3} \approx 3.23.
\]
We verify in simulation that the maximum error is $0.003$ and that the distance traveled is $2.41$, both satisfying our predicted bounds. Figure~\ref{fig:scaledversions} shows the same precomputed motion primitive scaled to reach a variety of goal configurations.

\begin{figure}[t!]
\centering
\href{http://www.youtube.com/watch?v=DcDCg0Ne0vo}{\begin{overpic}[width=.95\columnwidth]{examples}
\end{overpic}}
\caption{
\label{fig:scaledversions}
Example trajectories for $k=4$ and $\phi=\pi/2$. All of them are scaled versions of the maneuver shown in Fig.~\ref{fig:simTraj}. Thin red lines are particular values of $\epsilon$, thick black lines are the entire ensemble at instants of time.  \href{http://www.youtube.com/watch?v=DcDCg0Ne0vo}{(Video online: http://www.youtube.com/watch?v=DcDCg0Ne0vo)}
%Full trajectories for particular values of $\epsilon$ are shown in red. Snapshots for all values of $\epsilon\in[0.8,1.2]$ at particular times are shown in black.
}
\end{figure}


%
%\subsubsection{Notes}
%\begin{itemize}

%\item It is possible to do a type of feedback by modifying~$c_{k}$ on the fly. For example, notice that we divide~$c_{k}$ into two parts anyway---so, it is easy to adjust or replace these parameters later. Also, it may be possible to do feedback by \textcolor{red}{linearizing about a nominal trajectory}. But, again, perhaps this is future work.

%\item It would be nice if our algorithm was recursive/hierarchical in the sense that we could ``add'' precision by moving farther, without changing our base motion. In other words, in our MATLAB implementation, we select the parameter~$N$, and execute~$8N+3$ maneuvers, involving a total of~$2N+1$ decision variables, indexed~$c_{k}$. When we increase~$N$, we must recompute~$c_{k}$, and do not expect the ``old'' values---e.g., $c_{1},c_{2},c_{3}$ when moving from~$N=1$ to~$N=2$---to remain the same. But, it sure would be nice if they did. In other words, it would be nice if we could increment~$N$ to~$N+1$ as necessary to achieve the desired precision, computing only the 2 ``new'' values~$c_{2N+2},c_{2N+3}$.

%\todo{A naive approach to doing this---keeping track of the vector-to-go and incrementing~$N$ by one (or even by~$m>1$) each time---does not work well with our set of primitives.}

%But, a different naive approach might work OK. In particular, we notice that the shorter is the distance we have to move, the ``better.'' So, we might make sequential motions, incrementing~$N$ each time. Perhaps this is not worth the effort at this time.

%\item Never forget that your ability to approximate~$\Delta x$ and~$\Delta y$ degrades with the ``spread,'' i.e., as the range of~$\epsilon$ increases.

%\item One interesting thing is that a larger~$\epsilon$ is actually beneficial in some cases, such as trying to move the ensemble into a circular formation, or something where you are actually trying to achieve dispersion.

%\end{itemize}


\section{Hardware Experiments}
\label{sec:hardware}

In this section we apply our approximate steering algorithm to a differential-drive robot with unknown but bounded wheel radius.
First, we describe the robot that we used.
% in our experiments.
Then, we show that \eqref{eq:oneuncertain} is an appropriate model of this robot.
Finally, we show the results of hardware experiments.




\subsection{Experimental Setup}


   \begin{figure}
      \centering
      \href{http://www.youtube.com/watch?v=8yYD_KMwfaM}{\includegraphics[width=0.75\columnwidth]{Seg_4125.pdf}}
      \caption{The differential-drive robot used for experimental validation. Robot courtesy of College of Engineering Control Systems Laboratory~\cite{Block2004}.}
      \label{fig:Seg_4.125.pdf}
   \end{figure}

Figure~\ref{fig:Seg_4.125.pdf} shows the robot we used in our experiments.
It is a differential-drive robot with a caster wheel in front for stability.
It moves on a flat tile floor and uses only dead-reckoning for navigation.
In particular, the robot runs a feedback control loop to read the wheel encoders, update a dead-reckoning position estimate, and regulate the speed of each motor.

Although we use no other sensors for feedback control,
global position data is available from an off-board vision system for later analysis.
This vision system records pose information at 27 Hz with a position accuracy of 2 cm and an orientation accuracy of $1^{\circ}$. 

Before conducting our experiments, we applied a standard calibration procedure to find the effective wheelbase and wheel radius in order to reduce systematic dead-reckoning error~\cite{Borenstein1995,Borenstein1996}.
The calibration was done with wheels of diameter 12.7 cm.
However, these wheels are interchangeable---in our experiments, we used four sets that varied between 10.16-15.24 cm in diameter, as shown in Fig.~\ref{fig:Wheels.pdf}.
We did not recalibrate for these other wheels, and assumed that the wheel diameter was unknown but bounded in the set $[10.2,15.2]$, or in other words the set $[0.8,1.2]$ relative to the nominal diameter 12.7 cm.



\subsection{Application of the Model to a Differential-Drive Robot}

We will show that
\[
\dot{q}(t) = \epsilon\left( g_1(q(t)) u_1(t) + g_2(q(t)) u_2(t) \right)
\]
is a valid
kinematic
model of our
%differential-drive
robot,
where
% with unknown but bounded wheel radius, where
\[
g_1(q) = \begin{bmatrix} \cos{q_{3}}\\ \sin{q_{3}}\\ 0 \end{bmatrix}
\qquad\text{and}\qquad
g_2(q) = \begin{bmatrix}  0\\ 0\\ 1 \end{bmatrix}.\qquad
\]
It suffices to show that the forward speed $v$ and turning rate $\omega$ of a differential-drive robot with unknown but bounded wheel radius are given by ${v=\epsilon u_{1}}$ and ${\omega = \epsilon u_{2}}$, respectively, for control inputs~$u_{1},u_{2}\in\R$.
% and some parameter $\epsilon$ that captures the uncertainty.
Recall that for
%Recall that the forward speed~$v$ and turning rate~$\omega$ of a differential-drive robot with
wheel radius~$r$ and wheel separation~$l$, the forward speed and turning rate of a differential-drive robot are given by

\[
v = \frac{r (\omega_{R}+\omega_{L})}{2} \qquad\text{and}\qquad
\omega = \frac{r (\omega_{R}-\omega_{L})}{l},
\]
where~$\omega_{R}$ and~$\omega_{L}$ are the angular velocities of the right and left wheels, respectively.
Assume that the wheel radius, a positive constant, is unknown but bounded according to $r\in[r_\text{min},r_\text{max}]$.
If we define
\[
\bar{r} = \frac{r_\text{max}+r_\text{min}}{2}
 \qquad\text{and}\qquad
\delta = \frac{r_\text{max}-r_\text{min}}{2\bar{r}}\;\;
\]
then we can write~$r = \epsilon \bar{r}$ for some~$\epsilon \in [1-\delta,1+\delta]$,
so that

\[
v = \epsilon\left(\frac{\bar{r} (\omega_{R}+\omega_{L})}{2}\right)\quad\text{and}\quad
\omega = \epsilon\left(\frac{\bar{r} (\omega_{R}-\omega_{L})}{l}\right).
\]
This expression simplifies if we select
wheel angular velocities
%according to
\begin{align*}
\omega_{R} &= \frac{2u_{1}+bu_{2}}{2\bar{r}} \quad\text{and}\quad \omega_{L} = \frac{2u_{1}-bu_{2}}{2\bar{r}}
\end{align*}
for any given~$u_{1},u_{2}\in\R$,
so that
\begin{align*}
v &= \epsilon u_{1} \quad\text{and}\quad  \omega = \epsilon u_{2},
\end{align*}
and we have our result.





   \begin{figure}
      \centering
      \includegraphics[width=.9\columnwidth]{Wheels.pdf}
      \caption{Four wheel sizes used for experimental validation. These wheels are 10.16, 10.48, 12.7 and 15.24 cm in diameter.}
      \label{fig:Wheels.pdf}
   \end{figure}
   
\subsection{Experimental Results}

Figures~\ref{fig:TrajectoryPlotShould} and \ref{fig:DataTrajectory.pdf} show the results of our experiments, which successfully validated our approach.
\begin{figure}
      \centering 
\href{http://www.youtube.com/watch?v=8yYD_KMwfaM}{\begin{overpic}[width=.8\textwidth]{TrajectoryPlotShould}
\put(18,5){0}
\put(46,5){2}
\put(75,5){4}
\put(10,12){0}
\put(10,40){2}
\put(55,10){\begin{overpic}[width=.275\columnwidth]{Wheels.pdf}\end{overpic}}
\put(50,0){m}
\put(5,40){\begin{sideways}m\end{sideways}}
\end{overpic}}
 \caption{Expected paths for four wheel sizes on a move to [4.25,2.25] m.  Red, grey, blue and black plots correspond to 10.16, 10.48, 12.7 and 15.24 cm wheels, respectively.   }
      \label{fig:TrajectoryPlotShould}
\end{figure}
   \begin{figure}
      \centering 
\href{http://www.youtube.com/watch?v=8yYD_KMwfaM}{\begin{overpic}[width=.8\columnwidth]{TrajectoryPlotNO_NUM.pdf}
\put(18,4){0}
\put(46.5,4){2}
\put(75.2,4){4}
\put(10,11){0}
\put(10,39){2}
\put(55,10){\begin{overpic}[width=.275\columnwidth]{Wheels.pdf}\end{overpic}}
\put(50,0){m}
\put(5,40){\begin{sideways}m\end{sideways}}
\end{overpic}}
      \caption{  \label{fig:DataTrajectory.pdf}
      Ground truth data gathered from the camera system.  Five runs for each wheel set are shown.  Loops at the corners are artifacts from the camera system. Red, grey, blue and black plots correspond to 10.16, 10.48, 12.7 and 15.24 cm wheels, respectively.\\   
      \href{http://www.youtube.com/watch?v=8yYD_KMwfaM}{(Video online: http://www.youtube.com/watch?v=8yYD\_KMwfaM)}
      }
   \end{figure}
The start configuration was $(0,0,0)$. The goal configuration was $(4.25\text{ m}, 2.25\text{ m},0)$.
%We selected a goal location at $x = 4.25, y= 2.25$ m with the robot starting at the origin, and an error tolerance of 2cm.
The value of $k$ was chosen to achieve an error tolerance of $2\text{ cm}$.
We applied the algorithm described in Section~\ref{sec:algorithm} to generate a
single input trajectory
that was applied in open-loop.
%that steers the robot
%to a neighborhood of the goal position regardless of wheel size.
%from start to goal regardless of its wheel size.
%single sequence of inputs---i.e., single path---that will take the robot from start to goal regardless of its wheel size.
Five runs were recorded for each wheel size.
%Figure~\ref{fig:DataTrajectory.pdf} shows the resulting trajectories, all of which reached a small neighborhood of the goal position.
All of the resulting trajectories reached a small neighborhood of the goal position, as shown in Fig.~\ref{fig:EndingPoints.pdf} and reported in aggregate in Table~\ref{errormeasurements} and Fig.~\ref{fig:OptimVsTheoreticaldd}.
The size of this neighborhood is slightly larger than the predicted tolerance of $2\text{ cm}$.
This error is due largely to drift as a result of wheel slip, gear backlash, surface irregularities, wheel flex, and other disturbances.
Another contributing factor is that different wheels are made of different materials.
The $10.48\text{ cm}$ wheels are aluminum with rubber o-rings stretched over the rim, while the other wheels are ABS plastic with a molded rubber traction ring on the rim.
The edge of each plastic wheel has a rectangular cross-section, making the effective wheel base slightly larger than for the aluminum wheels.
%Differing in-group mean and variance (Table~\ref{errormeasurements})
The vision system also adds to observed error (although we emphasize that this vision system was used only for data collection and not for closed-loop feedback in our experiments).
In particular, ground truth position information was calculated from fiducial markers on the top of the robot. These markers were level and centered over the wheelbase for the $10.48\text{ cm}$ wheels, but tilted by $10^{\circ}$ for the largest wheels.




   \begin{figure}
      \centering 
\begin{overpic}[width=.8\columnwidth]{EndingPointsNO_NUM.pdf}
\put(34.4,4){4.1}
\put(59,4){4.2}
%\put(59,0){m}
\put(83.5,4){4.3}

\put(7,19){2.1}
\put(7,43.5){2.2}
\put(50,0){m}
\put(2,40){\begin{sideways}m\end{sideways}}
\end{overpic}
      \caption{Ending position for each run.  Green `+' for goal position, `x' for expected ending position under zero odometry drift, `o' for actual ending positions. Red, grey, blue and black plots correspond to 10.16, 10.48, 12.7 and 15.24 cm wheels. (Note the zoomed scale.)}
      \label{fig:EndingPoints.pdf}
   \end{figure}

    	   \begin{figure}%[htb]
	\begin{center} %TODO: change color for theoretical
		\begin{overpic}[width=\columnwidth]{TheoryExpForDiffDrive}\end{overpic}
	\end{center}
	\caption{ \label{fig:OptimVsTheoreticaldd} Distance error for four wheel sizes on a move to [4.25,2.25].  This test was repeated 5 times per wheel size.  The yellow line is the theoretical error.  The red line shows the mean errors for each wheel size tested $\pm$ one standard deviation.
	}
	\end{figure} 




\begin{table}
\small
\caption{In-group Error Measurements}
\label{errormeasurements}
\begin{center}
\begin{tabular}{|c||c|c|c|c|}
\hline
wheel &   distance  &  distance  & $\theta$      & $\theta$\\
 diam(cm) & mean(m) & var (m$^2$) & mean(rad) & var(rad)$^2$\\ 
\hline
10.16  & 0.10 &  3.2e-5  & -0.002 & 1.9e-6\\
\hline
10.48 &  0.02 &  4.1e-5  & -0.002 & 6.1e-7\\
\hline
12.70 &  0.08 &  1.2e-4  & -0.008 & 2.5e-5\\
\hline
15.24 &  0.19 &  2.2e-4  & -0.017 & 1.9e-4\\
\hline
\end{tabular}
\end{center}
\end{table}






\section{Conclusion}
\label{sec:conclusion}

In this chapter we applied the framework of ensemble control theory to derive an approximate steering algorithm that brings a nonholonomic unicycle to within an arbitrarily small neighborhood of any given Cartesian position despite model perturbation that scales both the forward speed and the turning rate by an unknown but bounded constant.
%In this paper we applied the framework of ensemble control theory to derive a motion planning algorithm that steers a nonholonomic unicycle from start to goal despite uncertainty that scales both the forward speed and the turning rate by an unknown but bounded constant.
This algorithm has trivial computational complexity, requiring only the solution of linear equations.
We validated our approach using a differential-drive robot with unknown but bounded wheel radius and showed the results with hardware experiments.
%What is perhaps most remarkable about our approach is that the algorithm we produce has trivial computational complexity.

In Chapter \ref{chap:ApproxPlate-BallSteering}, we apply a similar approach to a different robotic system, the plate-ball system.    In this case the full state of the plate-ball system is controllable.
 Later, in Chapter \ref{chap:FeedbackControlDiffDrive} we revisit robots with unicycle kinematics.  In that chapter, instead of steering one robot with an unknown parameter, we are interested in steering many such robots using a common control input.  %There are several techniques for steering a single unicycle with full state feedback.  In this case having full-state feedback does not solve the problem.  %We prove that the system is ensemble controllable and We provide a control law for steering  with full-state feedback.  In this case
 


%We hope that these results stimulate interest in ensemble control theory and provoke a new line of inquiry that may ultimately lead to practical application in robotics.



