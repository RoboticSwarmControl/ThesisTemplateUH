\chapter[Approximate Steering of Plate-Ball System under Bounded Model Perturbation]{Approximate Steering of Plate-Ball System under Bounded Model Perturbation}\label{chap:ApproxPlate-BallSteering}

% TODO: switch everything from radius = r/\epsilon to epsilon/r.  This allows the similarities between ch 2 and 3 to be obvious and removes a lot of fractions.


%Solution:  Use classical when referring to antiquity or music. Use classic when referring to something of highest quality.   We are talking about the old way, which is classsical
In this chapter we revisit the classical plate-ball system and prove this system remains controllable under model perturbation that scales the ball radius by an unknown but bounded constant. 
We present an algorithm for approximate steering and validate the algorithm with hardware experiments. To perform these experiments we introduce a new version of the plate-ball system based on magnetic actuation shown in Fig.~\ref{fig:CNCtable}.  This system is easy to implement and, with our steering algorithm, enables simultaneous manipulation of multiple balls with different radii. 
 \blfootnote{ Material from this chapter appeared in a preliminary  conference version as \cite{Becker2012j}.}

	   
    \begin{figure}%[htb]
	\begin{center}
	\href{http://www.youtube.com/watch?v=nPGz0Nd3QzE}{\begin{overpic}[width=\columnwidth]{CNCsetupPic}
	\end{overpic}}
%		\put(20,20){grid array of 15 magnets}
%		\put(40,10){$xy$ CNC table}
%		\end{overpic}
%		\begin{overpic}[width=.9\columnwidth,grid]{CNCmagnetSM}
%		\put(20,20){grid array of 15 magnets}
%		\put(40,10){$xy$ CNC table}
%		\end{overpic}
%		
%		\vspace{1em}
%		\begin{overpic}[width=.9\columnwidth,grid]{CNCwSpheresSMoverlay}
%		\put(60,-5){9 spheres}
%		\put(5,30){nonmoving substrate}
%		\end{overpic}
	\end{center}
	\caption{ \label{fig:CNCtable} The ensemble plate-ball system consists of an array of $n$ metal spheres separated from an array of $n$ magnets by a stationary sheet of cardboard.  The magnet array is attached to an $xy$ CNC table, and the spheres roll without slipping above their respective magnets. \\
	\href{http://www.youtube.com/watch?v=nPGz0Nd3QzE}{(Video online: http://www.youtube.com/watch?v=nPGz0Nd3QzE)} 
%In this chapter we prove this system, which applies the same control to each sphere, is approximately controllable.  We then describe and implement controllers that approximately steer spheres of unknown diameters from a starting orientation to a goal orientation.	
%	Top:  a table-top CNC mill table used as an $xy$ planar manipulator to slide a tray in the plane.  The tray is manufactured of MDF and is bolted to the mill.  15 holes are drilled into the surface. Each holds a 5mm$\times$8mm diameter cylindrical neodymium rare-earth magnet flush to the surface of the tray. The $xy$ table provides a $230\times125$mm workspace. Bottom: by securing a stationary,  0.15mm thick cardboard sheet on top of the tray, we have a manipulator that can roll variable-sizes ferro-magnetic spheres in the plane with minimal slip.  In overlay are shown 9 spheres of increasing diameter used to test manipulation algorithms in this chapter.
}
\end{figure}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Introduction}\label{sec:Intro}%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%P1: the classical system
%Manipulation by rolling contacts is a convenient way to achieve dexterity with simple hardware.  This problem is of considerable interest to the robotic community (see \cite{Brockett1993, Armour2006, Marigo2000, Bicchi1995, Choudhury2001, Mukherjee2002,Date2004,Oriolo2005,Svinin2008a,Casagrande2009}).  

The plate-ball system is a canonical example of manipulation by rolling contacts \cite{Brockett1993}. In the classical version of this system, the ball is held between two parallel plates and manipulated by maneuvering the upper plate while holding the lower plate fixed.  The ball can be brought to any position and orientation though translations of the upper plate.
%The classical plate-ball system manipulates a ball in SO(3) by rolling without slipping in the plane. 

%P2: the variant of the problem that we consider, noting right up front that this variant has also been consider by (for example?) Oriolo et al.
 We consider a variant of the plate-ball system in which the ball radius is an unknown but bounded constant. This variant has been considered previously by Oriolo et al. \cite{Oriolo2005}, who proposed a method of iterative feedback control. We are interested in the case where no sensor feedback is available.
 
 %P3: our approach to solving this problem
 Our main contribution is to prove this system is still controllable and present an algorithm for approximate (open-loop) steering.  To do so, we apply the framework of ensemble control theory \cite{Brockett1999,Khaneja2000,Li2009,Li2011,Becker2012} to derive an approximate  %Li2006,Li2006b,Li2006a,Li2007
steering algorithm. % for a sphere that rolls without slipping in the presence of model perturbation that scales the sphere radii by an unknown but bounded constant. 
The basic idea, similar to early work on sensorless manipulation \cite{Erdmann1988}, is to maintain the set of all possible configurations of the sphere and to select inputs that reduce the size of this set and drive it toward some goal configuration. The key insight is that the evolution of this set can be described by a family of control systems that depend continuously on the unknown constant. Ensemble control theory provides conditions under which it is possible to steer this entire family to a neighborhood of the goal configuration with a single open-loop input trajectory. These conditions mimic classical tests of nonlinear controllability like
the Lie algebra rank condition~\cite{Sussmann1972}
but involve approximations by repeated Lie bracketing that are reminiscent of seminal work on steering nonholonomic systems by Lafferriere and Sussman~\cite{Lafferriere1993}.

%P4: the other contribution of this chapter, your new platform (I might even think of a clever way to structure the intro so you can say something like this chapter has two contributions, the first one (the "main" one) is blah (ensemble control stuff) and the second one is blah (new platform stuff)
Our second contribution is a new experimental version of the plate-ball system based on magnetic actuation, shown in Fig.~\ref{fig:CNCtable}.  This platform has several advantages over traditional plate-ball systems.  The magnetic actuation makes the mechanism easy to implement, allows an unobstructed view of the ball on the plane, and enables simultaneous manipulation of multiple balls.  If these balls have unique radii, by using our algorithm this system can steer each ball to independent arbitrary orientations and simultaneously translate the balls to a desired position.

This result hints at a new approach to robust manipulation of so-called ``toleranced parts'' \cite{Requicha1983,Akella2000a}, an ongoing problem in automated assembly and industrial parts handling.
A considerable amount of work remains to be done, however, before ideas like this one find their way into practice.



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Manipulation by Rolling}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Manipulation of spherical objects by rolling has been investigated in depth by members of the math, control, and robotic manipulation community. % For an overview of rolling both in nature and robotics, see \cite{Armour2006}.  %%% BAD REFERENCE: only about spherical rolling robots, not manipulation --however, this might be cool for commanding a bunch of spherical robots with the same input....
 This research can be traced to Brockett and Dai who analyzed an approximation of the problem and determined the optimal controller for this approximation\cite{Brockett1993}.  
Jurdjevic analyzed the optimal shortest-length paths, showing that the optimal solution curve minimizes the integral of the geodesic curvature\cite{Jurdjevic1993}. %and that these curves are solutions to Euler's elastica problem
Two optimal shortest-length paths (calculated using the psuedospectral optimization solver GPOPS \cite{Garg2011,Rao2010,Benson2006,Garg2010,Garg2011b}) are shown in Fig.~\ref{fig:OptimalPathTurnZPiInPlace}. 
\begin{figure}%[htb]
	\begin{center}
		\begin{overpic}[width=.49\columnwidth]{OptimalPathTurnZPiInPlace}\end{overpic}
		\begin{overpic}[width=.49\columnwidth]{OptimalPathTranslateX2}\end{overpic}\\
%		\begin{overpic}[width=.4\columnwidth]{OptimalPathturnZinPlaceFINAL}\end{overpic}
%		\hspace{2em}
%		\begin{overpic}[width=.4\columnwidth]{optimalPathtranslateX2FINAL}\end{overpic}
%TODO:  show starting and ending path after flipping the sign of the x-axis
	\end{center}
	\caption{\label{fig:OptimalPathTurnZPiInPlace}Optimal shortest paths for a single sphere rolling on the plane to a desired position and orientation.  This optimal control problem was first investigated by Jurdjevic \cite{Jurdjevic1993}.  Green shows the initial ball position, dashed red the final position, and the path of the contact point between the ball and plate is in blue. The left path creates a net rotation of $\pi$ about the $z$-axis with no change in position while the right path translates the ball 1 diameter in the positive $x$ direction with no change in orientation. }
\end{figure}

  Li provided a symbolic algorithm for steering a plate-ball system \cite{Li1990}, while Marigo gave a numeric algorithm \cite{Marigo2000}.  Several practical stabilizing controllers were presented in \cite{Date 2004,Das2004,Morin2008, Casagrande2009},
and Oriolo and Vendittelli presented an iterative feedback controller for stabilizing the plate-ball system \cite{Oriolo2003,Oriolo2005}.  
 Oriolo and Vendittelli's  method is noteworthy because it guarantees asymptotic stability with exponential convergence.    This policy iterates between driving the orientation error to zero in finite time and controlling the position error to zero while cycling the orientation variables.  This feedback control policy is robust to a perturbed radius value.  A \textsc{Matlab} implementation of their policy is available online \cite{Becker2012b}, and can be used to generate the results shown in Fig.~\ref{fig:OrioloX2}.  When sensors are available, robust feedback control is, in general, more effective than what we propose.  However, these control techniques do not generalize to simultaneously control multiple balls with the same plate-ball system. %Their algorithm does not extend to multiple spheres and requires feedback.

\begin{figure}%[htb]
	\begin{center}\href{http://www.mathworks.com/matlabcentral/fileexchange/36252}{
		\begin{overpic}[height=.37\columnwidth]{OrioloX2positionerror}\end{overpic}
		\begin{overpic}[height=.37\columnwidth]{OrioloX2Porientation}\end{overpic} }
		%\begin{overpic}[width=.3\columnwidth]{OrioloX2Path}\end{overpic}
	\end{center}
	\caption{\label{fig:OrioloX2}  Oriolo and Vendittelli presented an iterative approach for stabilizing the plate-ball system.  Our implementation of their algorithm is shown above for moving a ball 1 diameter in the positive $x$ direction with no net change in orientation. This policy iterates between driving the orientation error to zero in finite time (red lines) and controlling the position error to zero while cycling the orientation variables (blue lines).  }
\end{figure}
 %This was applied specifically to 

Svinin and Hosoe extended the problem to plate-ball systems with limited contact area \cite{Svinin2008,Svinin2008a}.  This enables the manipulation of objects that are only partially spherical, such as a hemisphere.  

Several robotic plate-ball systems have been implemented (see \cite{Marigo2000, Bicchi1995}).
Our approach using multiple balls is inherently underactuated, and in that respect is similar to Choudhury and Lynch's work that showed a single degree-of-freedom manipulator was sufficient for orienting a sphere.  They  designed a hardware system consisting of an elliptical bowl mounted on top of a linear motor with the bowl's primary axis oriented 45 degrees from the linear motor orientation \cite{Choudhury2001}. By applying acceleration profiles to the linear motor, their approach steered the orientation to a desired coordinate in SO(3).


%% COOL, BUT DOESN"T APPLY
%Future work could extent the control demonstrated in this chapter to closed loop manipulation.  Similar examples in robotics include recent work by Yim and Sitti involving a soft robot containing two permanent magnets that are rolled about a walled 3D environment by an external magnet \cite{Yim2012}.  Using permanent magnets allowed them to reliably orient either the north or south pole of the robot at arbitrary points on the boundary of the environment. 
   
    Lastly, the control algorithms demonstrated in this work might find application at a much smaller scale using microspheres.  Studies by Ding et al.\ on rolling friction of microspheres \cite{DING2007} demonstrate that even on the micro-scale spheres can roll with little slip.  A study by Agayan et al.\ of the slipping friction of optically and magnetically manipulated microspheres on glass-water interface demonstrated techniques for manipulation that may benefit from our methodology \cite{Agayan2008}.  
 
  
%   Lastly, in this chapter we demonstrate that a continuum of differently-sized spheres is controllable.  This means a finite number of spheres with heterogeneity in diameter are also controllable.   Such a controller would be similar to the micro manipulation of Diller and Sitti et al.  They  controlled the 2D coordinates of multiple micro-scale permanent magnets by exploiting heterogeneity in the magnet's dimensions \cite{Diller2012}.  


%\subsection{Ensemble Control of Bloch Equations}
%We are motivated by a body of work on the ensemble controllability properties  of the Bloch equations 
%\cite{Li2007,Li2011,Beauchard2010a,Beauchard2010}.  The Bloch equations evolve a unit vector in $\R^3$ with inhomogeneity caused by RF-dispersion.  Much of this work can be applied to studying the evolution of the orientation of a sphere with an unknown radius.



%P5: outline of the chapter, explaining concisely what is where and why
The remainder of this chapter proceeds as follows. We begin with our problem statement (Section \ref{sec:ProblemStatement}). We then prove our problem  is controllable (Section \ref{sec:Controllability}).  We design an approximate steering algorithm (Section \ref{sec:ControllerDesign}), 
and validate the algorithm with a new hardware platform (Section \ref{sec:HardwareImplementationInfSphere}).  We discuss broader implications in our concluding remarks (Section \ref{sec:Conclusion}).
%In this chapter we consider the problem of steering a sphere to a desired configuration despite model perturbations that scale the sphere diameter by an unknown but bounded constant.  
%We focus on the sphere because it is a ubiquitous elementary component in manufacturing.  Additionally, sphere manipulation through rolling is a canonical example of a non-flat nonholonomic mechanism.   




%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Problem Statement}\label{sec:ProblemStatement}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%We  are interested in approximate steering of the orientation and position of a sphere with unknown diameter by rolling on the plane.
%\subsection{One Sphere}
% The configuration is a subset of SE(3) with the $z$ parameter set to 0.

  \begin{figure}
      \centering
      \begin{overpic}[width=\columnwidth]{SphereEnsCont3Dred.png}%{SphereEnsCont}
				\put(22,38){$\textcolor{blue}{r/\epsilon}$ }
				\put(62,15){$y$ }
				\put(30,20){$x$ }
				\put(20,51){$u_1$ }
				\put(38,58){$\Omega_y$ }
				\put(73,33){$u_2$ }
				\put(60,53){$\Omega_x$ }	
	\end{overpic}
	      \caption{\label{fig:SphereEnsCont}
A sphere with an unknown radius $r/\epsilon$ rolling on the horizontal plane.  This chapter models such a sphere as an ensemble control system, proves that it is controllable, and derives a motion planning algorithm that steers the sphere to within an arbitrarily small neighborhood of any desired configuration in $\R^2\times SO(3)$.}
   \end{figure} 
%
%  \begin{figure}
%      \centering
%      \begin{overpic}[width=.5\columnwidth]{SphereEnsCont}
%				\put(72,47){$\textcolor{blue}{r\epsilon}$ }
%				\put(18,10){$x$ }
%				\put(75,25){$y$ }
%				
%	\end{overpic}
%      \caption{\label{fig:SphereEnsCont}
%A sphere rolling on the plane with an unknown radius $r/\epsilon$.  This chapter models such a sphere as an ensemble control system, proves that it is controllable, and derives a motion planning algorithm that steers the sphere to within an arbitrarily small neighborhood of any desired configuration in $\R^2\times SO(3)$.}
%   \end{figure} 

%\item[$q$] configuration of an agent\item[$\Cspace$] configuration space
Consider the system shown in Fig.~\ref{fig:SphereEnsCont}, a sphere of radius $r$ that rolls without slipping on a horizontal plane. 
Following Jurdjevic \cite{Jurdjevic1993}, we describe its configuration $q$ by  $\left([x,y]^{\top},
R\right)$ consisting of the position $[x,y]^{\top}$ and the rotation matrix $R$.  The configuration space $\Cspace$ is $\R^2\times SO(3)$.   The control inputs are $u_{1}$  and
$u_{2}$, the velocities of the sphere center in the $+x$ and $+y$ directions.
We define the infinitesimal generators of rotation \[\Omega_x = \begin{bmatrix}
0 &0 & 0 \\
0 &0 & 1\\
0&-1 & 0 \end{bmatrix},
\quad
\Omega_y =\begin{bmatrix}
0 &0 & -1 \\
0 &0 & 0\\
1&0 & 0 
\end{bmatrix},\quad
\Omega_z =\begin{bmatrix}
0 &1 & 0 \\
-1 &0 & 0\\
0 &0 & 0 
\end{bmatrix},
\]
and  write the kinematics of the sphere by the differential system
\begin{align}
\label{eq:oneInfSphere}
\dot{x}(t) &= u_1(t)\nonumber\\
\dot{y}(t) &= u_2(t)\\
\dot{R}(t) &=  R(t) \frac{1}{r}   \bigg(  \Omega_x  u_1(t) + \Omega_y u_2(t) \bigg).\nonumber
\end{align}


%%%%%% Jurdgevics proof does not have the scaling by r.
%%%%%The configuration space $\Cspace$ is described by the five-dimensional Lie Group $\R^2\times SO(3)$ with the group operation
%%%%%\[ (a_1,R_1)(a_2,R_2) =(a_1+a_2,R_1R_2).\] 
%%%%%
%%%%%The Lie bracket is $[(a_1,R_1),(a_2,R_2) ] = (0,R_2R_1 - R_1R_2)]$.
%%%%%Corresponding to these inputs, we define 
%%%%%a basis for the Lie algebra of $\Cspace$ 
%%%%%\[
%%%%%\mathbf{e}_1 = \begin{bmatrix}1\\0\end{bmatrix},  \quad
%%%%%\mathbf{e}_2 = \begin{bmatrix}0\\1\end{bmatrix}, \quad   \Omega_x,\quad \Omega_y,\quad
%%%%%\Omega_z.
%%%%%\]
%%%%%
%%%%%%vector fields~$g_1,g_2\colon\Cspace\to{T_q\Cspace}$ by
%%%%%%\[
%%%%%%g_1(R) =R/r\begin{bmatrix}
%%%%%%0 &0 & -1 \\
%%%%%%0 &0 & 0\\
%%%%%%1&0 & 0 \\
%%%%%%\end{bmatrix} 
%%%%%%\quad
%%%%%%g_2(R) = R/r\begin{bmatrix}
%%%%%%0 &0 & 0 \\
%%%%%%0 &0 & 1\\
%%%%%%0&-1 & 0 \\
%%%%%%\end{bmatrix} 
%%%%%%\]
%%%%%
%%%%%
%%%%%We denote by $\mathbf{E}_1,\mathbf{E}_2,\mathbf{E}_1,\bm{\Omega}_x,\bm{\Omega}_y,$ and $\bm{\Omega}_z$  the left-invariant vector fields whose values at the identity are respectively equal to $(\mathbf{e}_1,0),(\mathbf{e}_2,0),(0,\Omega_x),(0,\Omega_y)$, and $(0,\Omega_z).$ We define $\bm{X}_1 = \mathbf{E}_1-\bm{\Omega}_y$ and $\bm{X}_2 = \mathbf{E}_2+\bm{\Omega}_1$ and  rewrite \ref{eq:oneInfSphere} as
%%%%%\begin{align}
%%%%%\label{eq:oneInfSphereLeftInvariant}
%%%%%\dot{q} &= u_1(t) \bm{X}_1(q) + u_2(t) \bm{X}_2(q) .\nonumber
%%%%%\end{align}
%%%%%The Lie Algebra generated by $\bm{X}_1$ $\bm{X}_2$ spans $\Cspace$ and thus for any $\qstart,\qgoal\in \Cspace$, and $T>0$, there exist control functions $u(1)$ and $u(2)$  such that the system trajectory progresses from $\qstart$ at $t=0$ and passes through $\qgoal$ at $t=T$.  



Given $\qstart,\qgoal\in \R^2\times SO(3)$, a gain $K \in [0,1]$ that weights the relative importance of rotation and position error, and an error bound $\mu>0$, the approximate steering
problem is to find open-loop inputs
\[
\left(u_{1}(t),u_{2}(t)\right) \colon [0,T] \to \Uspace
\]
that result in $\big([x(0),y(0)]^{\top},R(0)\big)=\qstart$ and 
%\begin{equation*}
%\operatorname{angle}\!\left(R(T),\Rgoal\right) + K \sqrt{   \big(x(T) -\xgoal \big) + \big( y(T) - \ygoal \big) } \leq\mu
%\end{equation*} 

\begin{equation*}
K\norm{ \begin{bmatrix}x(T)\\y(T)\end{bmatrix} -\begin{bmatrix}x_{goal}\\y_{goal}\end{bmatrix} }_2 + (1-K)\operatorname{angle}\!\Big(R(T),R_{\text{goal}}\Big) \leq\mu \\
\end{equation*} 
%\begin{equation*}
%\operatorname{angle}\!\left(R(T),\Rgoal\right) + K \norm{ \begin{bmatrix}x(T)\\y(T)\end{bmatrix}-\begin{bmatrix}\xgoal\\ \ygoal \end{bmatrix} }\leq\mu
%\end{equation*} 
for free final time $T$. Here
\[\operatorname{angle}\!\Big(R_a,R_b\Big) = \arccos\left(\frac{\operatorname{trace}\left(R_a^{\top}R_b\right)-1}{2}\right)\] is the minimum rotation angle between two rotation matrices. 
If such inputs always exist then we say that \eqref{eq:oneInfSphere} is {\em approximately controllable}---and indeed they do, as shown in \cite{Jurdjevic1993}.
%, since $x$ and $y$ are directly controllable and $\Omega_x $, $\Omega_y$, and the Lie bracket $[\Omega_x,\Omega_y]$ span the tangent space $T_{R}\left(SO(3)\right)$ everywhere.


    

\subsection{Ensemble of Spheres}

We will solve this same approximate steering problem, but for a sphere with radius $r/\epsilon$, where $\epsilon$ is an unknown but bounded constant. The resulting kinematics have the form
\begin{align}
\label{eq:oneInfSphereuncertain}
\dot{x}(t) &= u_1(t)\nonumber\\
\dot{y}(t) &= u_2(t)\\
\dot{R}(t) &= R(t)  \frac{\epsilon}{r}  \begin{bmatrix}
0 &0 & -u_2\\
0 &0 & u_1\\
u_2&-u_1 & 0 \\
\end{bmatrix} \nonumber
\end{align}
where $\epsilon^{-1} \in [1-\delta, 1+\delta]$ for some $0 \leq \delta < 1$. Rather than try to steer one sphere governed by \eqref{eq:oneInfSphereuncertain}---where $\epsilon$ is unknown---our approach is to steer an uncountably infinite collection of spheres parameterized by~$\epsilon$, each one governed by
\begin{align} \label{eq:ensembleInfSphere}
\dot{x}(t) &= u_1(t)\nonumber\\
\dot{y}(t) &= u_2(t)\\
\dot{R}(t,\epsilon) &=   R(t,\epsilon) \frac{\epsilon}{r} \bigg( \Omega_x u_1(t) + \Omega_y u_2(t) \bigg)\nonumber.
\end{align}
We call this fictitious collection of spheres an {\em ensemble} and call~\eqref{eq:ensembleInfSphere} an {\em ensemble control system}.
The idea is that if we can find
open-loop inputs $u_{1}(t)$ and $u_{2}(t)$ that result in $\big([x(0),y(0)]^{\top},R(0,\epsilon)\big)=\qstart$ and
%\[\operatorname{angle}\!\left(R(T,\epsilon),\Rgoal\right) + K \sqrt{   \big(x(T) -\xgoal \big) + \big( y(T) - \ygoal \big) } \leq\mu\]
\[K\norm{ \begin{bmatrix}x(T)\\y(T)\end{bmatrix} -\begin{bmatrix}x_{goal}\\y_{goal}\end{bmatrix} }_2 + (1-K)\operatorname{angle}\!\Big(R(T,\epsilon),R_{\text{goal}}\Big) \leq\mu \]
for all $\epsilon^{-1} \in [1-\delta,1+\delta]$, then we can certainly guarantee that the actual sphere, which corresponds to one particular value $\epsilon^{\ast}$ of $\epsilon$, will satisfy 
%\[\operatorname{angle}\!\left(R(T,\epsilon^{\ast}),\Rgoal\right) + K \sqrt{   \big(x(T) -\xgoal \big) + \big( y(T) - \ygoal \big) } \leq\mu.\]
\[K\norm{ \begin{bmatrix}x(T)\\y(T)\end{bmatrix} -\begin{bmatrix}x_{goal}\\y_{goal}\end{bmatrix} }_2 + (1-K)\operatorname{angle}\!\Big(R(T,\epsilon^{\ast}),R_{\text{goal}}\Big) \leq\mu \]
If such inputs always exist then we say that \eqref{eq:ensembleInfSphere} is {\em ensemble controllable},
defined as being approximately controllable on the function space \[L_{2}\left([1-\delta,1+\delta],\R^2\times SO(3)\right).\]






%\subsection{Ensemble Control of Spheres}
%%\begin{figure}%[htb]
%%	\begin{center}
%%		\begin{overpic}[width=.49\columnwidth]{SphereSimMid}\end{overpic}
%%		\begin{overpic}[width=.49\columnwidth]{SphereSimEnd}\end{overpic}
%%	\end{center}
%%	\label{fig:9sphereSim}
%%	\caption{ Nine spheres, with radius $[0.5,\ldots,1.5]$ roll down identical grooves, shown in blue.  All spheres finish with a net rotation of $\approx\pi$ about their $y$-axis.}
%%\end{figure}
%We will solve this motion planning problem, but under a model perturbation that scales the sphere diameter by some unknown, bounded constant, i.e.  $r_{actual} = r \epsilon$, $\epsilon \in [1-\delta,1+\delta]$.  However, rather than try to steer a single sphere governed by the perturbed kinematic model, our approach is to steer an uncountably infinite collection of spheres parameterized by $\epsilon$, each governed by the exact kinematic model
%\begin{align}
%\frac{d \,x(t,\epsilon)}{dt} &= u, \quad \frac{d \,y(t,\epsilon)}{dt} = v,\nonumber\\
%\frac{d \,R(t,\epsilon)}{dt} &= R(t,\epsilon) \begin{bmatrix}
%0 &0 & -u/(r \epsilon) \\
%0 &0 & v/(r \epsilon) \\
%u/(r \epsilon) &-v/(r \epsilon)  & 0 \\
%\end{bmatrix} 
%\label{eqn:EnsSphereSys}
%\end{align}
%
%Following the terminology introduced by recent work in control theory \cite{Li2006,Li2006a,Li2006b,Li2007,Li2011,Becker2010}, we call this fictitious collection of spheres an \emph{ensemble} and call the model \eqref{eqn:EnsSphereSys} an \emph{ensemble control system}.  The idea is that if we can find  open-loop inputs $u(t)$ and $v(t)$ that result in $g(0,\epsilon) = g_{start}$ and  $\norm{g(T,\epsilon) - g_{goal}} \le \mu$ for all $\epsilon  \in [1-\delta,1+\delta]$, then we can certainly guarantee that the actual sphere, which corresponds to one particular value of $\epsilon$, will be steered from the start to the goal.
%
%One optimization problem then is to minimize  
%\begin{align}
%\frac{1}{2}\int_0^T\left(u^2+v^2\right)dt
%\label{eqn:EnsSphereOpt}
%\end{align}
%over all possible solution curves of \eqref{eqn:EnsSphereSys} under the constraint that  $\norm{g(T,\epsilon) - g_{goal} }
%\le \mu$, $ \forall \epsilon  \in [1-\delta,1+\delta]$ for some $\mu > 0$.  
% 
%If we want the sphere rolling to be driven by gravity, it would be convenient to constrain  $\left[u,v\right] \in \R^+$.  %Section \ref{sec:Mechanics}  considers controlling the orientation of the ensemble under this constraint.
%
%A solution to \eqref{eqn:EnsSphereOpt} is not included in this note.   A proof of controllability and an algorithm for steering an ensemble toward  a goal orientation as a function of $\epsilon$ in $SO(3), \mathbf{R}(\epsilon)_{goal}$ is given in section III-A of \cite{Li2009}.  Interestingly, this algorithm is in-place such that $\Delta x = \Delta y = 0$.  Therefore, to get to a goal $[x,y,\mathbf{R} _{goal}]\in \R^2\times SO(3)$ requires only first rolling about the world $y$-axis to the desired $x$ position, followed by a roll about the world $x$-axis to the desired $y$ position.  These two movements generate some rotation $\mathbf{R}(\epsilon)_{x,y}$.  Since the algorithm in III-A of \cite{Li2009} is in-place, we can apply it to generate the rotation $\left(\mathbf{R}(\epsilon)_{x,y}\right)^{-1}\mathbf{R}(\epsilon)_{goal}$ and we have the full solution.    Note that a different solution based on Fourier coefficients is given by Pryor in \cite{Pryor2007,Pryor2007a}. Neither of these feasible solutions is proven to be optimal. 
%

% that cannot be stabilized by smooth feedback 
%why we care:  

%It is obvious that many factory processes have high accuracy;  low precision ball bearings are accurate within $\pm$0.005 inches will precision within $\pm$0.00003in \cite{Eschmann1985}.     Other processes do not:  micro spheres (cite), organic products (cite), grown spheres (cite)
%
%Moreover, spheres are a fundamental component used in many other designs

%  Citations for GPOPS:  \cite{Garg2011}\cite{Rao2010} \cite{Benson2006} \cite{Garg2010}\cite{Garg2011b}


%
%\subsection{Sensorless Part Orientation}
%We are motivated by progress in sensorless part manipulation, particularly the work of   \cite{Erdmann1988}  and \cite{Canny1994} showing that simple actuators are often sufficient to robustly orient a wide array of planar objects without using sensors.  These works employed parallel-jaw grippers  \cite{Canny1994}, and a tray that could be tilted in two axis  \cite{Erdmann1988}. These methods exploit differences in part geometry. %Robustly orienting the rounded surface of a sphere offers special challenges due to its inherent symmetry. 



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Analysis of Controllability}\label{sec:Controllability}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
We will now prove that the system \eqref{eq:ensembleInfSphere} is ensemble controllable. We will do this by using repeated bracketing to get higher-order powers of $\epsilon$, and then by using polynomial approximation to construct arbitrary vector flows. This approach is similar to that in Chapter \ref{sec:analysis}.
\begin{theorem}
\label{thm:controllableInfSphere}
The system \eqref{eq:ensembleInfSphere}  is ensemble controllable.
\end{theorem}
\begin{IEEEproof} We will first show that we can generate arbitrary changes in the ensemble orientation with no net change in $x,y$ position.
Any rotation $A$ in SO(3) can be parameterized by the rotations $\psi,\phi,\theta$ about the world $z$-axis, $x$-axis and then $z$-axis.
\[ A = R_z(\theta)R_x(\phi)R_z(\psi) \]
To approximate any rotation $A$ with an ensemble, it is then sufficient to construct the three approximate rotations 
\[R_z\!\big(\theta(\epsilon)\big) \approx R_z(\theta), \quad R_x\!\big(\phi(\epsilon)\big) \approx R_x(\phi), \text{ and } R_z\!\big(\psi(\epsilon)\big)\approx R_z(\psi).\]

We will proceed by showing how to construct $R_z\!\big(\theta(\epsilon)\big)$.
For small time $dt$, by rolling clockwise on the horizontal plane in a square pattern with sides of length $\sqrt{dt}$, we can approximate  a counter-clockwise rotation about the $z$-axis
\begin{align*}
 \exp\{\epsilon \sqrt{dt} \Omega_y\} \exp\{-\epsilon \sqrt{dt} \Omega_x\}
 \exp\{-\epsilon \sqrt{dt} \Omega_y\} &\exp\{\epsilon \sqrt{dt} \Omega_x\} \\ 
	  %&\approx  I + \epsilon^{-2} dt \Omega_z\\
	&  = \exp\{-\epsilon^{2} dt  \Omega_z\} + O\left(\epsilon^{3}\right).
	  \end{align*}
This Lie bracket movement generates the previously restricted motion about the $z$-axis, but the final $x $ and $y$ positions are unchanged.	  
%That is $[ \epsilon^{-1}\Omega_x,\epsilon^{-1}\Omega_y] = \epsilon^{-2}\Omega_z$.
% Here $\Omega_x,\Omega_y,\Omega_z,$ are  the differential inputs
% \begin{align*}
%\Omega_x = \begin{bmatrix}
%0 &0 & 0 \\
%0 &0 &-1 \\
%0 &1 & 0 \\
%\end{bmatrix},  
%\Omega_y = \begin{bmatrix}
%0 &0 & 1 \\
%0 &0 & 0 \\
%-1&0 & 0 \\
%\end{bmatrix}, 
%\Omega_z = \begin{bmatrix}
%0 &-1 & 0 \\
%1 &0 & 0 \\
%0 &0 & 0 \\
%\end{bmatrix}. 
% \end{align*}
 %This generates the rotation, to first order,
% \[\dot{R}(t,\epsilon) = \frac{1}{\epsilon}[ u \Omega_y + v \Omega_x ] R(t,\epsilon).\]
%\[R = \exp\{
 %\[M(t,\epsilon) = R M(0,\epsilon) \]
%\subsection{Analysis of an ensemble}
We take further Lie brackets to find new control vector fields:
%\frac{-1}{\epsilon} \Omega_y \cdot \frac{-1}{\epsilon}\Omega_x \cdot  \frac{1}{\epsilon}\Omega_y \cdot \frac{1}{\epsilon}\Omega_x\\
\begin{align*}
\left[ \epsilon \Omega_y, \epsilon \Omega_x\right] &=
 \begin{bmatrix}
0 &\epsilon^{2} & 0 \\
-\epsilon^{2} &0 & 0 \\
0&0 & 0 \\
\end{bmatrix} \\
&= -\epsilon^{2} \Omega_z\\
 \left[\epsilon \Omega_y \left[ \epsilon \Omega_y, \epsilon \Omega_x\right] \right] &= -\epsilon^{3}\Omega_x\\
\left[\epsilon \Omega_y \left[\epsilon \Omega_y \left[ \epsilon \Omega_y, \epsilon \Omega_x\right] \right]\right]&= \epsilon^{4}\Omega_z\\
&\vdots\\
&= -1^{k} \epsilon^{2k}\Omega_z \\
&= -1^{k} \epsilon^{2k-1}\Omega_x.
\end{align*}   % the adjoint

By successive Lie brackets, we can produce control vector fields of the form $\{\epsilon^{2k}\Omega_z\}$ and $\{\epsilon^{2k-1}\Omega_x\}$ for any $k\ge1$ that leave the Cartesian position of the sphere unchanged.  As in  Chapter \ref{sec:controllableInfUnicycle}, 
with piecewise-constant inputs we can produce flows of the form
% With these terms as generators, we can approximate the rotation
\[\exp\left\{\sum_{k=1}^m  a_k \epsilon^{2k}\Omega_z \right\}\]   
for freely chosen constants $a \in \R^m$. 
%where  the order $m$ and the coefficients $a_k$ can be selected such that
%\[ \norm{\alpha - \sum_{k=0}^m  a_k \epsilon^{-2k} } \le \mu, \quad \forall \epsilon\in[1-\delta,1+\delta], \]
%letting us match a desired rotation $\exp\{\alpha \Omega_x\}$ to arbitrary accuracy.
%A similar rotation can be generated about $\Omega_z$ to any desired accuracy.
The Stone-Weierstrass theorem~\cite{Royden1988} tells us that given~$\eta > 0$ and a continuous real function
\[
\nu(\epsilon) \colon [1-\delta,1+\delta] \to \R,
\]
there exists a polynomial function~$\rho(\epsilon)$ such that
\[
\abs{\rho(\epsilon) - \nu(\epsilon)} < \eta
\]
for all~$\epsilon \in [\underline{\epsilon},\overline{\epsilon}]$.
An immediate corollary is that
continuous real functions
on the domain $[\overline{\epsilon}^{-1},\underline{\epsilon}^{-1}]=[1-\delta,1+\delta]$ for some ${0\leq\delta<1}$ can be uniformly approximated either by an odd polynomial or by an even polynomial. (This result would not be true on an arbitrary domain, which is why we restrict ${\delta<1}$.) As a consequence,
%there exist polynomials
we can choose $a\in\R^{m}$ so that
\begin{align*}
\theta(\epsilon) &\approx \sum_{k=1}^{m} a_{i}\epsilon^{2k} 
%\beta(\epsilon) &\approx \sum_{i=0}^{k-1} b_{i}\epsilon^{2i+2}
\end{align*}
for $\epsilon^{-1}\in[1-\delta,1+\delta]$, with error vanishing in $k$.
%Given $\mu>0$, 
The time complexity of the resulting motion increases with $k$ and with the number of switches required to approximate flows along each
vector field  $\epsilon^{2k}\Omega_{z}$ and $\epsilon^{2k-1}\Omega_{x}$, but remains finite for any given $\mu>0$.
%Additionally, the classical plate-ball system is steerable in $\R^2\times SO(3)$.  Our controllability result of section \ref{sec:Controllability} used bracket motion to reorient the spheres.  These bracket motions are rotations in a square pattern on the plane, and leave the sphere $x$ and $y$ position unchanged.  Therefore we can steer from a given $[x_{start},y_{start},\Rstart]$ to a desired $[x_{goal},y_{goal},\Rgoal]\in [\R^2\times SO(3)]$.  We apply a straight line rotation to move the ensemble of spheres to $x_{goal},y_{goal}$.  This move incurs some rotation $\phi(\epsilon)$.   We finish by performing a rotation in place that approximates $\Rgoal \phi(\epsilon)^{\top} \Rstart^{\top}$. 

We further note that every Lie bracket movement is a roll in a closed pattern on the horizontal plane and thus  leaves the final sphere $x$ and $y$ position unchanged.
 To steer the ensemble from \[\big([\xstart,\ystart]^{\top},\Rstart\big) \text{ to } \big([\xgoal,\ygoal]^{\top},\Rgoal\big),\]
we can rotate first in $x$ and then in $y$ to $(\xgoal,\ygoal)$, resulting in the net rotation  
\[R_1(\epsilon) = R_y\left(\frac{\ygoal-\ystart}{\epsilon}\right)R_x\left(\frac{\xgoal-\xstart}{\epsilon}\right)\Rstart.\] 
We then approximate the ensemble rotation $A(\epsilon) = \Rgoal R_1^{\top}(\epsilon)$ through Lie bracket movement.
%We conclude that \eqref{eq:subsystem} is ensemble controllable.
Our result follows.\end{IEEEproof}

 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 \section{Approximate Steering Algorithm}\label{sec:ControllerDesign}
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

 \begin{table}
 \caption{Orientation Method 1: Taylor Series Approximation} \label{tab:TaylorSeriesApprox}
 %\newcolumntype{C}{>{\centering\arraybackslash} m{
\begin{tabular}{| m{4cm} | >{\centering\arraybackslash}m{4cm} |  m{5cm} |  }
  \hline                         
  Path Name & Example Path & Rotation \\
  \hline   \hline 
  \small \raggedright Piecewise-constant rolling primitive \[\text{(Section \ref{subsec:NonLinearRolling})}\]& \vspace{1em}\begin{overpic}[width=4cm]{NonlinearPrimForTable}	\end{overpic} & \[\approx R_y\left(\beta_k \epsilon \cos\left(\phi k \epsilon\right)\right)\]   \\ \hline
   \small \raggedright($n$th-order) Taylor series approximate rotation (using $n$ piecewise-constant rolling primitives) \[\text{(Section \ref{subsec:RotatingApproxAboutXaxis})}\] & \begin{overpic}[width=4cm]{pryor3primPathSim}	\end{overpic} & \[\approx R_y\left(\sum_{k=0}^{n-1} \beta_k \epsilon \cos\left(\phi k \epsilon \right)\right) \]   \\ \hline
   \small \raggedright
  Two-step rotation using two Taylor series approximate rotations to approximate  $R_z(\phi_3)R_x(\phi_2)R_z(\phi_1)$\[\text{(Section \ref{subsec:ArbOrientation2Rolls})}\] & \begin{overpic}[width=4cm]{TwoStepTaylorPathSim}	\end{overpic} & 
  %\[\approx R_{p}\bigg(r(\phi-\pi),\theta\bigg)\]\[ \cdot R_{p}\bigg(r\pi,(\theta-\psi)/2\bigg)\] \\
   \[\approx R_{p}\big(r(\phi_2-\pi),\phi_3\big)\qquad \qquad \qquad \qquad\qquad\]\[ \qquad\cdot R_{p}\big(r\pi,(\phi_3-\phi_1)/2\big)\qquad \qquad \qquad \qquad\] \\

  \hline  
\end{tabular}
\end{table}

 \begin{table}
 \caption{Orientation Method 2: $n$-Segment Optimized Path} \label{tab:nSegmenOptimizedPath}
 %\newcolumntype{C}{>{\centering\arraybackslash} m{
\begin{tabular}{| m{4cm} | >{\centering\arraybackslash}m{4cm} |  m{5cm} |  }
  \hline                         
  Path Name & Example Path & Rotation \\
  \hline   \hline 
   \small $n$-Segment $\text{Optimized~Path}$ \[\text{(Section \ref{subsec:OptimalControl})}\] & \begin{overpic}[width=4cm]{optimprimPathsim}	\end{overpic} & \vspace{1em}$R(\Theta,\epsilon)$ \[ = \prod_{i = 1}^{n}{R_x\!\left(\frac{\epsilon}{r} \theta_{2i-1}\right) R_y\!\left(\frac{ \epsilon}{r} \theta_{2i}  \right) }\] \\
  \hline  
\end{tabular}
\end{table}

 
 In this section we provide two methods for approximate open-loop steering of a rolling sphere with an unknown radius. An overview of each is shown in Tables \ref{tab:TaylorSeriesApprox} and \ref{tab:nSegmenOptimizedPath}.  The first method consists of concatenating Taylor series approximations of  in-plane rotations.   Since each rotation is approximate, using fewer rotations reduces the cumulative orientation error. It is well known that three orthogonal rotations span SO(3). We show that two straight line rolls on the horizontal plane also span SO(3) \cite{Becker2012c}.  
%    We next construct a motion primitive that approximates a rotation of $\theta$ about the world $x$-axis for spheres with radii $\in [1-\delta,1+\delta]$.  Two of these primitives then is sufficient to approximately reorient all spheres with radii $\in [1-\delta,1+\delta]$ to any orientation in SO(3).

   We conclude the section with a second method for approximate open-loop steering of a rolling sphere using an optimized $n$-segment path. 
 
 %%% Discrete optimization is a branch of optimization in applied mathematics and computer science. As opposed to continuous optimization, the variables used in the mathematical program (or some of them) are restricted to assume only discrete values, such as the integers.
 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 \subsection{Piecewise-Constant Rolling Primitive}\label{subsec:NonLinearRolling}
% Without loss of generality, we will assume that $R(0,\epsilon)$ is the identity matrix.
Consider the motion primitive given by Pryor in \cite{Pryor2007,Pryor2007a} of the following form for a non-negative integer~$k$, and freely chosen~$\phi,\beta_{k} \in \R$:



\begin{equation}
(u_1,u_2)
=
\begin{cases}
(0,-1) & \mathrlap{0}\hphantom{\dotsm   } \leq t < \phi k \\
(1,0) & \dotsm   \leq t < \dotsm+  \beta_k/2\\
(0,1) & \dotsm \leq t < \dotsm+ 2\phi k \\
(1,0) & \dotsm  \leq t < \dotsm+  \beta_k/2\\
(0,-1) & \dotsm \leq t < \dotsm+ \phi k \\   
%(0,-1) & 0 \leq t < \phi k \\
%(1,0) & \phi k   \leq t < \phi k + \beta_k/2\\
%(0,1) & \phi k +\beta_k/2  \leq t < 3\phi k + \beta_k/2\\
%(1,0) & 3\phi k  +\beta_k/2 \leq t < 3\phi k + \beta_k\\
%(0,-1) & 3\phi k   +\beta_k \leq t < 4\phi k + \beta_k\\   
\end{cases}\label{eq:PWSpherePrim}
\end{equation}
Such a primitive is shown in Fig.~\ref{fig:PryorsPrim1} and requires  time $t =4\phi k + \beta_k$.
To first order, the result
is to achieve
\begin{align*}
\Delta x(\epsilon) &= \beta_k \\
\Delta y(\epsilon) &= 0, \\
\Delta R(\epsilon)  &= R_y\left(\beta_k \epsilon \cos\left(\phi k \epsilon\right)\right) + O(\beta_k^2)
\end{align*}

\begin{figure}%[htb]
		\begin{center}
			\begin{overpic}[width=.75\linewidth]{PryorsPrim1}
			\put(35,23){$-\phi k$}
			\put(16,34){$\beta_k/2$}
			\put(50,37){$2 \phi k$}
			\put(83,47){$\beta_k/2$}
			\put(68,50){$-\phi k$}
			\end{overpic}\\
			\vspace{2em}
			\begin{overpic}[width=.75\linewidth]{PryorsPrim1Subdivided}\end{overpic}
		\end{center}
		\caption{\label{fig:PryorsPrim1} (Top) A sample primitive of the form \eqref{eq:PWSpherePrim}, with $\beta_k = \pi/3$ and $\phi k = \pi/2$. A sphere following this path generates to first order the rotation   $R_y\left(\beta_k \epsilon  \cos(\phi k \epsilon)\right)$.  (Bottom) By subdividing the rotation we can improve arbitrarily this approximation, at the cost of a longer path. An outline of a unit radius sphere is shown in green at the start of the path and dashed in red at the end.}
\end{figure}       

%The approximation $R_y(\beta_k \frac{1}{\epsilon} \cos(\phi k \frac{1}{\epsilon}))$ is created by applying the motion primitive and taking the first-order Taylor series expansion at $\beta_k = 0$.  
The approximation degrades for large values of $\beta_k$, but by  repeating the primitive \eqref{eq:PWSpherePrim} $j$ times with parameter $\beta_k' = \beta_k/j$ the approximation improves. Pryor proved  in \cite{Pryor2007a} that we can build a primitive with arbitrary accuracy by increasing $j$.

 \subsection{Taylor Series Approximate Rotation}\label{subsec:RotatingApproxAboutXaxis}

Because the primitives \eqref{eq:PWSpherePrim} all rotate in the same direction, we are free to concatenate them. 
The result after applying $n$ primitives with $k=0,\dotsc,n-1$ is
\begin{align*}
\Delta x(\epsilon) &=  \sum_{k=0}^{n-1} \beta_{k}\\
\Delta y(\epsilon) &= 0 \\
\Delta R(\epsilon) &\approx \prod_{k=0}^{n-1} R_y\left(\beta_k \epsilon \cos\left(\phi k \epsilon\right)\right)\\
&\approx R_y\left(\sum_{k=0}^{n-1} \beta_k \epsilon \cos\left(\phi k \epsilon\right)\right)\\
&\approx R_y\left(\Delta \theta\left(\epsilon\right)\right),
\end{align*}
where we define 
\begin{equation} \label{eq:AngleTurnedByPryorPrims}
 \Delta \theta\left(\epsilon\right) =  \sum_{k=0}^{n-1} \beta_k \epsilon \cos\left(\phi k \epsilon \right).
 \end{equation}

\subsubsection{\bf{Achieving Error of a Particular Order:}\label{sec:UnicycleErrorOfParticularOrder}}

We may express the angle turned about the $y$-axis after applying $n$ primitives, $\Delta \theta\left(\epsilon\right)$, as a Taylor's series in $\epsilon$ about $\epsilon=1$:
\begin{align*}
\Delta \theta(\epsilon) &=
\Delta \theta(0)
+  \frac{\partial \Delta \theta}{\partial \epsilon}\biggr\rvert_{\epsilon=1} (\epsilon-1)
+ \cdots.
\end{align*}
This series has the form
\begin{align*}
\Delta \theta(\epsilon) &= \sum_{j=1}^{n} s_{j} (\epsilon-1)^{j-1} + O\left( | \epsilon -1 | ^{n}\right).
\end{align*}
%Note that this expression is linear in $s_{j}$, and that each coefficient $s_{j}$ is linear in $\beta_{1},\dotsc,\beta_{n}$.
Define
\[
s = \begin{bmatrix} s_{1} \\ \vdots \\ s_{n} \end{bmatrix},
\quad
\beta = \begin{bmatrix} \beta_{1} \\ \vdots \\ \beta_{n} \end{bmatrix},
\]
so we can write
\begin{equation}
\label{linearequationsInfSphere}
s = S\beta
\end{equation}
where the matrix $S\in\R^{n\times n}$ has elements
\begin{align*}
S_{ij} &= \frac{1}{\left(i-1\right)!} \left( \frac{\partial^{i-1} \left(\epsilon\cos\left(\epsilon j\phi\right)\right)}{\partial \epsilon^{i-1}}\biggr\rvert_{\epsilon=1}\right).
\end{align*}
To achieve $\Delta \theta=\alpha$ with error that is of order $n$ in $\epsilon$, we require only that $s = [\alpha, 0,  \ldots, 0 ]^{\top}$.

The achievable error decreases exponentially in the number $n$ of primitives used.
As in Chapter \ref{chap-infUnicycle}, we need to solve a system of $n$ linear equations to achieve $n$th-order error.
As a consequence, exactly $n$ primitives are required to achieve $n$th-order error, for any $n$.
There is the  implicit assumption here that  $S$ is nonsingular (and, in practice, well conditioned), but this assumption will hold for ``almost all'' choices of $\phi$.
%       
%For certain choices of $\phi$, the matrix $S$ has a very simple form.
%For example, taking $\phi=\pi/2$ and assuming $n=4$, we find that
%\[
%S =
%\begin{bmatrix}
%1 & 0 & -1 & 0 \\
%1 & -\pi/2 & -1 & 3\pi/2 \\
%0 & -\pi/2 & \pi^{2}/2 & 3\pi/2 \\
%0 & \pi^{3}/48 & \pi^{2}/16 & -27\pi^{3}/48
%\end{bmatrix}
%\]
%In this case, the linear equation~\eqref{linearequationsInfSphere} can be solved exactly to produce
%\[
%\beta =
%\begin{bmatrix}
%1+(2/\pi^{2}) \\
%3\left(8+3\pi^{2}\right)/\left(4\pi^{3}\right) \\
%2/\pi^{2} \\
%\left(24+\pi^{2}\right)/\left(12 \pi^{3}\right)
%\end{bmatrix}
%\]
By linearity, it is clear that the scaled parameters $\beta \Delta \theta$  will reach arbitrary $\Delta \theta$.
We can use this method to generate paths that satisfy arbitrary accuracy bounds, but these paths may be very long.  
  Fig \ref{fig:TaylorSeriesPaths} depicts paths generated to  turn $\pi$ about the $x$-axis with a threshold of $\pi/6$. 
  

%This primitive may be rotated about the $z$-axis to approximate any rotation in the plane. 
 This 2D path can then be rotated an angle $\psi$ about the $z$-axis by  \[\begin{bmatrix} \cos(\psi) & -\sin(\psi)\\ \sin(\psi) & \cos(\psi) \end{bmatrix}\] to approximate any in-plane rotation.

  
    \begin{figure}%[htb]
	\begin{center}
		\begin{overpic}[width=.49\columnwidth]{pryor1primPath}\put(20,40){$n=1$}\end{overpic}
		\begin{overpic}[width=.49\columnwidth]{pryor2primPath}\put(20,40){$n=2$}\end{overpic}\\
		\vspace{0.5mm}
		\begin{overpic}[width=.49\columnwidth]{pryor3primPath}\put(20,40){$n=3$}\end{overpic}
		\begin{overpic}[width=.49\columnwidth]{pryor4primPath}\put(20,40){$n=4$}\end{overpic}
	\end{center}
	\caption{ \label{fig:TaylorSeriesPaths} Rolling paths generated using Taylor series to approximate the rotation  $R_x(\pi)$ with a threshold of $\pi/6$ and a nominal ball radius of 10.3mm to (left to right, top to bottom) 1, 2, 3 and 4-th order.  Path lengths are \{32.4, 311.9, 584.0, 919.4\} mm. The start point is shown in green and the stop point in red. The $230\times125$ mm workspace for our manipulator is represented by a blue rectangle.
	}
\end{figure}

 \subsection{Arbitrary Orientation in SO(3) with Two Straight Rolls}\label{subsec:ArbOrientation2Rolls}
Any rotation $A$ can be generated by the three rotations $R_z(\theta)R_x(\phi)R_z(\psi)$ \cite{Becker2012c}.   This is illustrated in Fig \ref{fig:ballRollPlane} and proved below. 
%This corresponds to moving the north pole of the sphere to latitude $\phi$, longitude $\theta$, then twisting about the original north pole by $\psi$.
We use the shorthand notation $s_\alpha = \sin(\alpha)$, $c_\alpha = \cos(\alpha)$.
\begin{align*}
A &=R_z(\theta)R_x(\phi)R_z(\psi) \\
&= \left[
\begin{array}{ccc}
 c_{\theta} c_{\psi} -c_{\phi} s_{\theta} s_{\psi} & -c_{\phi} c_{\psi} s_{\theta} -c_{\theta} s_{\psi} & s_{\theta} s_{\phi} \\
 c_{\psi} s_{\theta}+c_{\theta} c_{\phi} s_{\psi} & c_{\theta} c_{\phi} c_{\psi}-s_{\theta} s_{\psi} & -c_{\theta} s_{\phi} \\
 s_{\phi} s_{\psi} & c_{\psi}s_{\phi} & c_{\phi}
\end{array}
\right].
 \end{align*}
 
 
   \begin{figure}%[htb]
	\begin{center}
	\vspace{4mm}
\href{http://demonstrations.wolfram.com/ReOrientASphereWithTwoStraightRolls/}{		\begin{overpic}[width=.85\columnwidth]{ballRollPlane}
		\put(4.5,39){$x$}
		\put(12,47){$y$}
		\put(7,52){$z$}
		\put(24,5){$\alpha_1 =\dfrac{\theta-\psi}{2}$}
		\put(40,18){\begin{turn}{8}$\ell_1 = r\pi$\end{turn}}
		\put(85,15){$\alpha_2 = \theta$}
		\put(64,35){\begin{turn}{-20}$\ell_2 = r(\phi-\pi)$\end{turn}}
		\put(42,80){$\theta$}
		\put(45,54){$\phi$}
		\put(67,80){$\psi$}
		\end{overpic}}
	\end{center}
	\caption{ \label{fig:ballRollPlane} Any orientation in SO(3) can be generated by two straight-line rolls on the horizontal plane.  Let $R_{p}(\ell,\alpha)$ represent a roll along a line of length $\ell$  making the angle $\alpha$ with the $x$-axis.  Then,	for a ball with radius $r$, 
	$R_z(\theta)R_x(\phi)R_z(\psi) =  R_{p}\left(r(\phi-\pi),\theta\right)R_{p}\left(r\pi,(\theta-\psi)/2\right).$ 
	\href{http://demonstrations.wolfram.com/ReOrientASphereWithTwoStraightRolls/}{(Video online: http://demonstrations.wolfram.com/ReOrientASphereWithTwoStraightRolls/)}}
\end{figure}
 
Our system is constrained to rolling on the horizontal plane. For a sphere of radius $r$, any roll along a line of length $\ell$  making the angle $\alpha$ with the $x$-axis results in the rotation 
 \begin{align*} R_{p}(\ell,\alpha) &=
 \left[
\begin{array}{ccc}
 c_{\alpha}^2+c_{\ell/r} s_{\alpha}^2 & (1-c_{\ell/r}) c_{\alpha} s_{\alpha} & s_{\ell/r} s_{\alpha} \\
 (1-c_{\ell/r}) c_{\alpha} s_{\alpha} & c_{\ell/r} c_{\alpha}^2+s_{\alpha}^2 & -c_{\alpha} s_{\ell/r} \\
 -s_{\ell/r} s_{\alpha} & c_{\alpha} s_{\ell/r} & c_{\ell/r}
\end{array}
\right].
  \end{align*}
 % $R_z(\theta)R_x(\phi)R_z(\psi) =  R_{p}\left(r(\phi-\pi),\theta\right)R_{p}\left(r\pi,(\theta-\psi)/2\right).$}
 The following two straight-line  rolls duplicate $R_z(\theta)R_x(\phi)R_z(\psi)$:
  \begin{align*}
 R_{p}\big(r(\phi-\pi),\theta\big)R_{p}\big(r\pi,(\theta-\psi)/2\big)&= \left[
\begin{array}{ccc}
 c_{\theta} c_{\psi} -c_{\phi} s_{\theta} s_{\psi} & -c_{\phi} c_{\psi} s_{\theta} -c_{\theta} s_{\psi} & s_{\theta} s_{\phi} \\
 c_{\psi} s_{\theta}+c_{\theta} c_{\phi} s_{\psi} & c_{\theta} c_{\phi} c_{\psi}-s_{\theta} s_{\psi} & -c_{\theta} s_{\phi} \\
 s_{\phi} s_{\psi} & c_{\psi}s_{\phi} & c_{\phi}
\end{array}
\right]\\
&=A
  \end{align*}
%  We can invert any rotation $A = R_z(\theta)R_x(\phi)R_z(\psi)$ with two straight line  rolls of the form $A^{-1} = R_{p}(\pi,\tfrac{1}{2}(\theta-\psi)) \cdot R_{p}(\pi-\phi,\theta)$.  The first movement rolls the sphere so that the original north pole is pointing down, and the second rotation returns the north pole to the original orientation.
%   \begin{align*} 
%  &R_{p}(\pi,\tfrac{1}{2}(\theta-\psi))R_{p}(\pi-\phi,\theta) \cdot R_z(\theta)R_x(\phi)R_z(\psi)\\
%  &=R_{p}(\pi,\tfrac{1}{2}(\theta-\psi))\cdot \left[
%\begin{array}{ccc}
% c_{\theta -\psi } & s_{\theta -\psi } & 0 \\
% s_{\theta -\psi } & -c_{\theta -\psi } & 0 \\
% 0 & 0 & -1
%\end{array}
%\right]\\
%&=\left[
%\begin{array}{ccc}
% 1 & 0 & 0 \\
% 0 & 1 & 0 \\
% 0 & 0 & 1
%\end{array}
%\right]    
%\end{align*}
The first rotation is of length $\ell_1 = r(\pi-\phi)$ with $\abs{\phi} \le \pi$ and the second rotation is of length $\ell_2 =r\pi$, giving a  total path length of  $ \pi r \le \ell_1+\ell_2 \le 2\pi r$.

We can now decompose any desired rotation in SO(3) into two straight line rotations with magnitude $\ell_1/r$ and $\ell_2/r$ radians. 
Each of these rotations can be implemented with the Taylor series approximate rotations of  Section \ref{subsec:RotatingApproxAboutXaxis}.
A drawback is that this method does not provide a way to control the change in $x$ and $y$.
 In the following section we use optimization to generate shorter paths that steer toward desired $(\Delta x,\Delta y,\Delta R)$ values.




%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Approximate Steering with $n$-Segment Optimized Path} \label{subsec:OptimalControl}%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

We want to steer an ensemble of spheres with radii $r/\epsilon$  to a desired rotation $\Rgoal$ and position $(\xgoal,\ygoal)$ by alternating rotations along the positive $x$ and $y$-axes.  The composite rotation $R(\Theta,\epsilon)$ after $n$ such rotations is 
\begin{align} \label{eqn:posRotations}
R(\Theta,\epsilon) &= \prod_{i = 1}^{n}{R_x\!\left(\frac{  \epsilon}{r} \theta_{2i-1} \right) R_y\!\left(\frac{ \epsilon}{r} \theta_{2i}\right)} \nonumber\\
\Delta x(\Theta) &= \sum_{i=1}^{n} \theta_{2i-1}\\
\Delta y(\Theta)  &= \sum_{i=1}^{n} \theta_{2i} \nonumber \\
\text{for }\Theta &= \left[\theta_1,\ldots,\theta_{2n}\right], \quad \theta_i \ge 0. \nonumber
\end{align}
%where $R_x(\alpha)$ is a rotation of $\alpha$ about the $x$-axis and $R_y(\beta)$ is a rotation of $\beta$ about the $y$-axis.  
We assume without loss of generality that $[\xstart,\ystart,\Rstart] = [0,0,\mathbb{I}(3)]$.
The problem is to find $\Theta$ such that 
\begin{align}
K \norm{ \begin{bmatrix}\Delta x(\Theta)\\\Delta y(\Theta)\end{bmatrix}-\begin{bmatrix}\xgoal\\ \ygoal \end{bmatrix} } _2+ \int_{1-\delta}^{1+\delta}\operatorname{angle}\left(R\left(\Theta,\epsilon\right)), \Rgoal \right) d\epsilon
\label{eqn:minSO3}
\end{align}
is minimized.  To simplify our optimization routine we replace the integral in \eqref{eqn:minSO3} with a summation over a finite set of $\epsilon$,  and use gradient descent on $\Theta$ from multiple random seed values $\Theta_{init}$  to search for local minima in 
\begin{align}
K \norm{ \begin{bmatrix}\Delta x(\Theta)\\\Delta y(\Theta)\end{bmatrix}-\begin{bmatrix}\xgoal\\ \ygoal \end{bmatrix} }_2 +\sum_{k = 0}^{N-1}\operatorname{angle}\!\left(R\left(\Theta,1-\delta +\frac{2\delta k}{ N-1}\right), \Rgoal  \right) \label{eqn:minNsegmentSO3}
\end{align}
For the paths generated in Fig.~\ref{fig:optimPaths}, we used a path with 10 segments, 500 random seed values, and $N = 15$.  %This optimization routine provided adequate results, but future work should take advantage of modern optimization methods.

% 
%  -- Pryor's primitive provides a method for generating a path to approximate an ensemble rotation of $\theta\in \R$ about the $x$-axis. This 2D path can then be rotated by 
%  $\begin{bmatrix} \cos(\psi) & -\sin(\psi)\\ \sin(\psi) & \cos(\psi) \end{bmatrix}$ to generate a rotation about any axis parallel to the plane.
%  

 
     
    \begin{figure}%[htb]
	\begin{center}
	\href{http://www.youtube.com/watch?v=nPGz0Nd3QzE}{
		\begin{overpic}[width=\columnwidth]{optimprimPath}\end{overpic}\\
		\vspace{2em}
		\begin{overpic}[width=\columnwidth]{optimprimPath3stage}
		\put(13,23){1.)``SPHERE''}
		\put(68,21){2.)``ORIENT''}
		\put(21,37){3.)``WITH 1''}
		\put(75,35.5){4.)``SIGNAL''}
%		\put(13,22.75){\scriptsize SPHERE}
%		\put(65,21){\scriptsize ORIENT }
%		\put(22,36.5){\scriptsize WITH 1}
%		\put(72,35){\scriptsize SIGNAL}
		\end{overpic}}
	\end{center}
	\caption{ \label{fig:optimPaths}Top: a 189 mm long path generated by optimization that rotates spheres approximately $R_x(\pi)$. 
Bottom: a 577 mm long three-stage path that rotates spheres approximately $R_x(\pi),R_z(\pi/2),R_x(\pi)$.  Six spheres were labelled so that different words appeared at the end of each stage. Snapshots from an experiment are shown in Fig.~\ref{fig: FourMoveSnapshot}.
Each path is composed of 10 segments and designed for ball radii of 10.3 mm$\pm25\%$.  The start point is shown in green, intermediate points in blue, and the stop point in red. The position error gain $K$ was $0$ for these paths.  
	}
\end{figure}


    \begin{figure}%[htb]
	\begin{center}
		\href{http://www.youtube.com/watch?v=nPGz0Nd3QzE}{\hspace{16mm}\begin{overpic}[width=.8\columnwidth]{FourMoveSnapshotSm}
		\put(-20,47){$1.)\Rstart$}
		\put(-20,32){$2.) R_x(\pi)$}
		\put(-20,18.5){$3.) R_z(\pi/2)$}
		\put(-20,5){$4.) R_x(\pi)$}
		\end{overpic}}
	\end{center}
	\caption{ \label{fig: FourMoveSnapshot}Snapshots of six different-sized spheres while rolling along the three-stage path in Fig \ref{fig:optimPaths}.  This path consists of a roll  that approximates $R_x(\pi)$, followed by $R_z(\pi/2)$, then $R_x(\pi)$.  Four letters were printed on appropriate sides of each sphere to illustrate the movement.\\
\href{http://www.youtube.com/watch?v=nPGz0Nd3QzE}{(Video online: http://www.youtube.com/watch?v=nPGz0Nd3QzE)}
}
\end{figure}
   %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 \section{Hardware Experiments}\label{sec:HardwareImplementationInfSphere}
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 To validate our control algorithms we built a ball-plate system based on magnetic actuation.  In this section we describe the system design, the methodology for state estimation, and characterize the system repeatability.  %The magnetic actuation makes the mechanism easy to implement, allows an unobstructed view of the ball on the plane, and enables simultaneous manipulation of multiple balls with different radii.
 \subsection{System Design}
   
    %The prototype spherical parts handler 
    Our ensemble plate-ball system is shown in Fig.~\ref{fig:CNCtable}, page \pageref{fig:CNCtable}.  
A grid array of $n$ magnets attached to a CNC xy-table can reorient $n$ spheres by rolling when a nonmoving substrate is placed between the spheres and magnet array.  A table-top CNC mill table (Sherline 8541 metric, 800 steps per mm) is used as an $xy$ planar manipulator to slide a tray in the horizontal plane.  The tray is manufactured of MDF and is bolted to the mill.  Fifteen holes are drilled into the surface. Each holds a $5\times8$ mm diameter cylindrical neodymium rare-earth magnet flush to the surface of the tray. The $xy$ table provides a $230\times125$ mm workspace. By securing a stationary,  $0.15$ mm thick cardboard sheet on top of the tray, we have a manipulator that can roll variable-sized ferro-magnetic spheres in the horizontal plane with minimal slip. Six steel ball-bearings with diameters $\{16,18,19,22,24,25.4\}$ mm  were used to test manipulation algorithms in this chapter. 

 Our prototype was inspired by the kinetic sculptures of Bruce Shapiro and Jean-Pierre H{\'e}bert, which draw paths in sand using a rolling steel ball actuated by a hidden servo-controlled magnet \cite{Shapiro1998,Hebert1999}.

%This platform has several advantages over traditional plate-ball systems.  The magnetic actuation makes the mechanism easy to implement, allows an unobstructed view of the ball on the plane, and enables simultaneous manipulation of multiple balls.  If the balls have unique radii, this system can steer each ball to arbitrary orientations.


    

\subsection{Measuring System Position and Orientation}\label{subsec:MeasureSysPosOrient}
%   Tracking the orientation of a sphere is a common problem, with approaches ranging from 
%     using colored circles painted at the vertices of Platonic solids \cite{Lynch2001},
%   painting a fiducial pattern on a sphere and then comparing camera images to a library of generated rotated images \cite{Robert-Zimmermann2011}, to tracking sphere orientation using dots precisely applied to the ball  \cite{Bradley2004}.  Each of these approaches requires accurate marker application, which increases in difficulty as the sphere shrinks in size.  An alternate approach applies fiducial stickers to the sphere, learns the positions during a training phase, and then tracks these fiducials \cite{Beeler2010}.  We adapted this method to use hand-drawn fiducials because stickers would affect the effective sphere diameter.  We then estimated the sphere position tracking 5 points in each image using Horn's method \cite{Horn1987}, producing at frame $k$ the rotation matrix $R_k$.  We used `$\top$' shaped fiducials. % we used are visible in Fig.~\ref{fig:ResultsOptimRollPicsl}.

To validate our control policies we must accurately measure the position and orientation of spheres as they are manipulated by the plate-ball system.
   Tracking the orientation of a sphere has inspired several approaches including 
     using colored circles painted at the vertices of Platonic solids \cite{Lynch2001},
   painting a fiducial pattern on a sphere and then comparing camera images to a library of generated rotated images \cite{Robert-Zimmermann2011}, applying a 2D Gray-coding to the sphere \cite{Chirikjian2003}, and estimating sphere orientation using many dots precisely applied to the ball  \cite{Bradley2004}.  Each of these approaches requires accurate marker application, which increases in difficulty as the sphere shrinks in size.  An alternate approach applies fiducial stickers to the sphere, learns the positions during a training phase, and then tracks these fiducials \cite{Beeler2010}.  
     For our initial approach, we adapted this method to use hand-drawn fiducials because stickers would affect the effective sphere diameter.  We then estimated the sphere position by tracking 5 points in each image using Horn's minimum least squares method \cite{Horn1987}, producing at frame $k$ the rotation matrix $R_k$.  We used `$\top$' shaped fiducials. % we used are visible in Fig.~\ref{fig:ResultsOptimRollPicsl}.
This method is only useful if the fiducial remains in view for all measurements.  Using a single fixed-position camera restricts $\Delta R$ to rotations about the optical axis---an overhead camera can only measure rotations about the $z$-axis.

To enable full state estimation, we followed the approach of Lynch \cite{Lynch2001}.  He showed that if markers are placed at the vertices of a dodecahedron and we can ensure one face is always visible, three marker colors is sufficient to determine the orientation. At least one face is always visible if the camera has a visible angle of $\ge 70.56^\circ$.   A 25.4 mm sphere requires the camera to be at least 36 mm away from the sphere.  In practice, markers far from the sphere center in the camera image become distorted and the lighting less reliable, so the camera must be further away.   In our setup the camera is 0.5 m from the sphere. 
% \alpha =\sqrt{\frac{d^2}{R^2-1}}
Our markers are circular because this shape is least affected by distortion as the sphere rolls. We selected the three colors $\{$\texttt{red,green,blue}$\}$ because they are easily discernible in HSV color space. 

\subsubsection{\emph{Implementation}}

We used steel ball-bearings 25.4 mm in diameter.  Spheres can be difficult to illuminate uniformly. To ease the load on our vision processing, we painted the balls flat white.  We washed the bearings with soap and water, spray-painted two coats of primer (Rust-Oleum grey primer 7582) and then over-coated with 3 thin coats of flat white (Rust-Oleum flat white 7590).  In our initial tests the markers were painted on with paint-pens (Elmer's Painters Red, Krylon Brights 60670323 and 07031664A).  Unfortunately this created raised bumps on the surface of the sphere that caused the ball to roll around rather than over the painted areas.  These deviations are clearly seen in Fig.~\ref{fig:ActualPaths4}, page~\pageref{fig:ActualPaths4}.  We switched to using colored pens (Pentel Color Pen FinePoint \#S360 102 Red, 111 Light Green, 136 Baby Blue) for subsequent tests. We illuminated the sphere by arranging a tube fluorescent light fixture at each of the four sides of the plate-ball table.

To accurately mark the vertices of a dodecahedron, we constructed a paper template of an icosahedron that encloses the sphere.  The centers of each face of this icosahedron form a dodecahedron that is circumscribed by the sphere.  We then drill out these centers in the template, fold the template around the sphere, and mark the vertices as shown in Fig.~\ref{fig:BallMarkingProcess}.
Given a sphere of radius $r$, the edges of the icosahedron whose faces are each tangent to the sphere are of length
\[ \frac{4 \sqrt{3} }{3 + \sqrt{5}} r \approx 1.323 r.\]
Our template, constructed for a sphere 25.4 mm in diameter, has edges 16.8 mm long.  The template, marking procedure and a camera frame after vision processing are shown in Fig.~\ref{fig:BallMarkingProcess}.

For vision processing we used a Basler 602fc color digital camera which captures $656 \times 490$ pixels at 100 fps.  Pseudo code for  measuring the translation and rotation is given in Alg.~\ref{alg:transrotOfSphere}.




\begin{algorithm}
\caption{\label{alg:transrotOfSphere}Measure Ball Translation $(x_b,y_b)$ and Rotation Matrix $R$ } 
\begin{algorithmic}[1]
%\small
	\State grab a frame 
	\State segment out the ball and measure ball center location and radius:\\
	$\qquad (x_b,y_b), r$
	\State adaptive threshold over the ball to find markers
	\State measure position of each marker:\\
	 $\qquad \big(x_i,y_i,r+\sqrt{r^2-(x_b-x_i)^2-(y_b-y_i)^2}\big)$
	\State assign marker color based on shortest distance of hue in HSV colorspace 
	\State create \emph{edgeList} (markers closer than a threshold distance in~$\R^3$)
	\If{depth-first-search on \emph{edgeList} finds 5 markers in a non-repeating loop}
		(this is a face)
		\State record colors of face vertices in CW order
		\State search through 60 possible color patterns to find matching face
		\State R = \textsc{Horn'sMethod}( 5 face markers, $(x_b,y_b,r)$ )
	\Else
		\ForAll{measured markers}
			\State compare marker positions to identified markers in  previous frame  
			\State record marker if colors match and distance is less than a threshold
		\EndFor
		\If {2 or more markers identified}
			\State R = \textsc{Horn'sMethod}(recorded markers, $(x_b,y_b,r)$) 
		\Else
			\State procedure failed
		\EndIf
	\EndIf
	\State record $R$, $(x_b,y_b)$
\end{algorithmic}
\end{algorithm}




 \begin{figure}%[htb]
	\href{http://www.youtube.com/watch?v=-9go60KxtRI}{\begin{tabular}{cc}
	        \begin{overpic}[height=.28\columnwidth]{icosahedronPattern}\end{overpic}
	        &
		\begin{overpic}[height=.28\columnwidth]{colorsphere1}\end{overpic}\\
		\begin{overpic}[height=.28\columnwidth]{colorsphere3}\end{overpic}
		& 
		\begin{overpic}[height=.28\columnwidth]{visionFrame}\end{overpic}
		\end{tabular}}
	\caption{\label{fig:BallMarkingProcess} The paper template (top) is used to mark 20 equally-spaced vertices such that each face has a unique pattern (bottom left).  A vision system identifies this pattern to determine the ball orientation and measures the ball position (bottom right). \\
	\href{http://www.youtube.com/watch?v=-9go60KxtRI}{(Video online: http://www.youtube.com/watch?v=-9go60KxtRI)}  }
\end{figure}



\subsection{Characterizing System Repeatability}
   \begin{figure}%[htb]
	\begin{center}
		\begin{overpic}[width=.9\columnwidth]{SubstrateTest1}\end{overpic}\\  %ExpDriftLine
		\vspace{5mm}
		\begin{overpic}[width=.9\columnwidth]{SubstrateTest2}\end{overpic} %ExpDriftSquare
	\end{center}
	\caption{ \label{fig:substrateDesign} Repeatability test for rolling 25.4 mm spheres. Every marker is the average of 3 trials and each test repeated a given pattern 10 times.   (Top) pattern 1: back and forth $2\pi$ in $x$,
(Bottom) pattern 2: a square box, each side a $2\pi$ rotation.
The best surfaces had a drift of about 0.09 radians per 250 radians 
%5 degrees per 15,000 degrees 
of commanded movement (0.04\% error).
	}
\end{figure}
Our control algorithm assumes the spheres roll without slipping.    To test the accuracy of this simplification, we ran a series of repeatability tests with different substrate materials.

  The substrate separates the metal spheres from the tray holding the magnets.  The non-moving substrate is clamped along the perimeter of the workspace. A good substrate should be thin, because magnetic strength decreases proportional to the inverse cube of the distance from the dipole.  The substrate should have low friction on the bottom surface that the tray and magnets slide along, but high friction on the top surface to prevent the spheres from slipping.  Moreover, the top surface should be flat and non-deformable so that rolling is uniform.  We tested 5 surfaces: 0.26 mm acrylic, 0.35 mm cardboard, 2 and 3 mm craft foam, and 1.5 mm thick stiff felt.  The craft foam had high friction with the tray, so we placed the acrylic sheet beneath the foam for all tests.  
   We ran two tests for each substrate material.
   \begin{description}
   	\item[Straight Line:] rolling $2 \pi r$ along the $x$-axis, then $-2\pi r$ to return to the origin.
   	\item[Square Box:] rolling in a square pattern with $-2\pi r$ sides.
   \end{description}
   
   Each test was run with three 25.4 mm diameter steel  (grade 200, $1\pm0.002$ in, sphericity within 0.002 in) spheres, and the patterns were repeated 10 times, with the orientation recorded at the beginning and at the end of each pattern.   These tests used slightly smaller permanent magnets (3$\times$8 mm diameter) than those used in the final prototype. Plots of the resulting orientation error are shown in Fig \ref{fig:substrateDesign}.  These plots show a steady increase in the average orientation error.  The best substrate material for all trials was 0.35 mm cardboard, followed by 0.26 mm acrylic,  2 mm foam, 3 mm foam, and 1.5 mm felt.  In the longer trials using the square box pattern, both the 3 mm craft foam and 1.5 mm  felt failed when the spheres detached from their magnets and rolled freely atop the surface.  The best surface, 0.15 mm cardboard, is thin, horizontally rigid, smooth, and a compromise for friction between the tray and between the spheres.  This surface had a drift of about 0.09 radians per 250 radians  of commanded movement, a 0.04\% error.
   


   
   
   %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Results}\label{subsec:Results}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

In this section we compare experimental results on our hardware platform.  We first compare rotation sequences generated by a Taylor's series approximation of various orders and paths discovered by a $n$-segment optimization. We then demonstrate how multiple paths can be concatenated to move an ensemble through a sequence of orientations.  Next, we compare approximating an arbitrary rotation---in this case rotating 2 radians about the $[3,2,1]$ axis by concatenating two sequences generated by Taylor series approximation and a sequence discovered using $n$-segment optimization. Our final test describes using $n$-segment optimization to generate movements in $\R^2\times SO(3)$.

%\begin{figure}%[htb]
%	\begin{center}
%	\vspace{3 mm}
%		\hspace{10mm}\begin{overpic}[width=.85\columnwidth]{BigOptimRollSM}
%		\put(3,30){$t_0$}
%		\put(13,30){$t_1$}
%		\put(23,30){$t_2$}
%		\put(33,30){$t_3$}
%		\put(43,30){$t_4$}
%		\put(53,30){$t_5$}
%		\put(63,30){$t_6$}
%		\put(73,30){$t_7$}
%		\put(83,30){$t_8$}
%		\put(93,30){$t_9$}
%		\scriptsize
%		\put(-8,22){$25.4$}
%		\put(-8,12){$24.0$}
%		\put(-8,2){$22.0$}
%		\end{overpic}
%	
%		\hspace{10mm}\begin{overpic}[width=.85\columnwidth]{littleOptimRollSM}
%		\put(-15,14){\begin{sideways} diameter (mm)\end{sideways} }
%		\scriptsize
%		\put(-8,22){$19.0$}
%		\put(-8,12){$18.0$}
%		\put(-8,2){$16.0$}
%		\end{overpic}
%
%	\end{center}
%	\caption{ \label{fig:ResultsOptimRollPicsl}  Positions of six different sized spheres after applying the 10 step motion primitive in Fig.~\ref{fig:optimPaths} that rotates spheres $\pi$ about the $y$-axis (pointing out of page).    Left to right: initial and first nine ending positions after applying the motion primitive.  The test was repeated for a total of 25 iterations for the results shown in Fig \ref{fig:OptimVsTheoretical}.
%}	
%\end{figure}

\begin{figure*}%[htb] 
\begin{center} 
		\begin{overpic}[width=.6\textwidth]{ExpOptimvs1to4pryor}\end{overpic}\\
		\vspace{-.9em}
		\begin{overpic}[width=.6\textwidth]{ExpOptimvs2to4pryor}\end{overpic}\\
		\vspace{-.9em}
		\begin{overpic}[width=.6\textwidth]{TheoryOptPryor}\end{overpic}\end{center}
	\caption{\label{fig:OptimVsTaylorSeriesApprox} Experimental results from applying the paths shown in Figs.\ \ref{fig:TaylorSeriesPaths} and \ref{fig:optimPaths}.    Six spheres with diameter [16,18,19,22,24,25.4] mm were tested.  For each sphere, the optimized path was tested 25 times and each primitive-based path was tested 10 times.   Error bars show $\pm$ one standard deviation.  The last plot shows the theoretical error.
	}
\end{figure*}

\begin{description}
\item[1. Testing Ensemble Rotation Primitives:]	
We compared motion primitives designed to rotate the ensemble approximately $\pi$ about the world $y$-axis.  All tests were performed with 6 spheres ranging in size $\pm$25\% of nominal diameter.  We compare primitives based on 1,2,3 and 4$^{th}$-order Taylor series with a 10-segment optimized path designed with position error gain $K = 0$.  
     These movements are primitives because they can be concatenated to approximate any desired rotation.  Note first that due to symmetry the path used to generate the rotation $R_y(a)$ can be rotated to generate a rotation of $a$ about any axis parallel to the plane.  Secondly, the Taylor series approximations can be linearly scaled in the $x$-axis direction to approximate any rotation $\beta$ about the world $y$-axis.
    	   \begin{figure}%[htb]
	\begin{center} %TODO: change color for theoretical
		\begin{overpic}[width=\columnwidth]{TheoryExpRadfor10Mvs}\end{overpic}
	\end{center}
	\caption{ \label{fig:OptimVsTheoretical} Accuracy test for six spheres with diameters [16,18,19,22,24,25.4] mm.  The spheres were commanded to follow the 10-segment path in Fig.~\ref{fig:optimPaths} designed by  optimization. This test was repeated 25 times.  The yellow line is the theoretical error.  The red line shows the mean errors for each sphere tested $\pm$ one standard deviation.
	}
	\end{figure}     
     The  Taylor series paths and the 10-segment optimized path are shown in Figs.~\ref{fig:TaylorSeriesPaths} and \ref{fig:optimPaths}.  These paths were tested by measuring the starting and ending orientation for 10 iterations of the Taylor series paths and 25 iterations of the optimized path.    The errors recorded for these tests are shown in Fig \ref{fig:OptimVsTaylorSeriesApprox} for all six sphere sizes.  % Fig \ref{fig:ResultsOptimRollPicsl} shows the initial and final orientations of each sphere for the optimized path.

For all spheres, the 10-segment optimized path performed best. Results from using this path are highlighted in Fig.~\ref{fig:OptimVsTheoretical}. 
The Taylor series-based paths increased in accuracy as the order increased from 1$^{st}$ to $3^{rd}$ order, but  the 4$^{th}$ order path decreased in accuracy.  The accuracy gained by the higher-order series approximation may have been cancelled by the process-induced drift shown in Fig \ref{fig:substrateDesign}.   

	    	 

\item[2. Following a Path Sequence:]
To demonstrate how motion primitives can be sequenced to complete a more complicated task, we concatenated three rolls that respectively approximate the rotations $R_x(\pi)$, $R_z(\pi/2)$, and $R_x(\pi)$.  
 The compound path is 577mm long and shown in Fig \ref{fig:optimPaths}.  We then selected six different-sized spheres and printed four letters on appropriate sides of each sphere to illustrate the movement. 
Fig.~\ref{fig: FourMoveSnapshot} shows four snapshots of these spheres while rolling along the three move path.    See \url{http://www.youtube.com/watch?v=-9go60KxtRI} for a video of this rotation sequence.


\item[3. Generating an Arbitrary Rotation:]



 
 Tests 3 and 4 were implemented using a single 25.4mm diameter sphere with 20 marked features.  For each test we generate 15 different paths for spheres with an assumed radius equally spaced  $0.75\times$ to $1.25\times$ the actual radius.

This experiment demonstrates how a Taylor series approximate rotation,  scaled and rotated appropriately, can be applied twice to approximate an arbitrary rotation in SO(3).  We then repeat the same test using a 12-segment optimized path. 
To demonstrate the method, we chose a rotation of 2 radians about the $[3,2,1]$ axis.  This corresponds to a rotation 
$R_z(\theta)R_x(\phi)R_z(\psi)$ with $\{\theta \approx 0.982426, \phi \approx 1.89125, \psi \approx -0.19358\}$.  As shown in section \ref{sec:ControllerDesign}
\[R_z(\theta)R_x(\phi)R_z(\psi) =  R_{p}\left(r(\phi-\pi),\theta\right)R_{p}\left(r\pi,(\theta-\psi)/2\right),\]
and so we design primitives to first roll a distance  $\pi r$ in the direction $0.588$ radians with the $x$-axis, followed by a roll of length $1.24r$ in the direction $0.98$ radians with the $x$-axis.   We then use a 12-segment optimized path for the same desired rotation and the additional constraint $(\Delta x, \Delta y) = (0,0)$ with position error gain $K = 0.98$.

\begin{figure}%[htb]
	\begin{center}
		\begin{overpic}[width=.48\columnwidth]{pryor2primPathRotate2radAxis321}\end{overpic}
		\begin{overpic}[width=.48\columnwidth]{discOptimPathRotate2radAxis321}\end{overpic}
	\end{center}
	\caption{\label{fig:ExpectedPath3} Paths for rotating 2 radians about the axis $[3,2,1]$. The left path was generated by a two-step rotation using a 2nd-order Taylor series approximation.  On the right is a 12-segment optimized path. 
	The path lengths are $\{ 2182, 326   %2182.55, 325.672,314.056,335.704
	\}$ mm. The start point is shown in green and the stop point in red. The $230\times125$ mm workspace for our manipulator is represented by a blue rectangle.  }
\end{figure}

 These desired paths are shown in Fig.~\ref{fig:ExpectedPath3}.  The actual paths for 15 different assumed ball radii are shown in Fig.~\ref{fig:ActualPaths3}.  Our vision system tracked angular error during these experiments, and the error as a function of path distance is shown in Fig.~\ref{fig:pathAngularError3}.  Note how the Taylor series solution oscillates around the desired rotation, while the optimized solution only converges at the end.  The final error for each test is shown in Fig.~\ref{fig:ExpAngularError3}.  The 12-segment optimized path  outperforms the path designed using Taylor series approximation.
 \begin{figure}%[htb]
	\begin{center}
	        \begin{overpic}[width=.8\columnwidth]{pathxyPRYOR_PATH_2RAD_ABOUT_321}\end{overpic}\\
		\begin{overpic}[width=.8\columnwidth]{pathxyENS_MOVE_X0_Y0_2RAD_ABOUT_321}\end{overpic}
	\end{center}
	\caption{\label{fig:ActualPaths3} Experimental paths followed for rotating 2 radians about the axis $[3,2,1]^{\top}$. Top, path  using Taylor series.  Bottom, 12-segment optimized path. 
 The path of contact point is shown. Units are mm.
 \newline (Consistent color for each assumed radius in Figs. \ref{fig:ActualPaths3}-\ref{fig:ExpAngularError3}) }
\end{figure}

 \begin{figure}%[htb]
	\begin{center}
	        \begin{overpic}[width=\columnwidth]{pathAngErrPRYOR_PATH_2RAD_ABOUT_321}
	        \put(5,26){\begin{sideways} error (rad)\end{sideways}}\end{overpic}\\
	        \begin{overpic}[width=\columnwidth]{pathAngErrENS_MOVE_X0_Y0_2RAD_ABOUT_321}
	        \put(5,26){\begin{sideways} error (rad)\end{sideways}}
		\put(35,-3){normalized path length}\end{overpic}
	\end{center}
	\caption{\label{fig:pathAngularError3}Measured angular error as a function of path length for different assumed radii while rotating 2 radians about the axis $[3,2,1]^{\top}$. Top, error using Taylor series approximate rotation, bottom error using 12-segment optimized-path. 
	\newline (Consistent color for each assumed radius in Figs. \ref{fig:ActualPaths3}-\ref{fig:ExpAngularError3})  }
\end{figure}


\begin{figure}%[htb]
	\begin{center}
	        \begin{overpic}[width=\columnwidth]{endAngErrPRYOR_PATH_2RAD_ABOUT_321}
	        \put(0,25){\begin{sideways} error (rad)\end{sideways}}\end{overpic}\\
		\begin{overpic}[width=\columnwidth]{endAngErrENS_MOVE_X0_Y0_2RAD_ABOUT_321}
		\put(0,25){\begin{sideways} error (rad)\end{sideways}}
		\put(45,-4){ radius$/\epsilon$}\end{overpic}\\
	\end{center}
	\caption{\label{fig:ExpAngularError3}  Measured ending angular error for rotating 2 radians about the axis $[3,2,1]^{\top}$. Top, error  using Taylor series approximate rotation, bottom error using 12-segment optimized path.   Note the different $y$ scales---following the optimized path results in 1/2 to 1/3 the error of the primitive-based path.
	\newline (Consistent color for each assumed radius in Figs. \ref{fig:ActualPaths3}-\ref{fig:ExpAngularError3})  }
\end{figure}




 \begin{figure}%[htb]
	\begin{center}
		\begin{overpic}[width=.49\columnwidth]{discOptimPathInPlaceRotateZpi}\end{overpic}
		\begin{overpic}[width=.49\columnwidth]{discOptimPathENS_MOVE_2X_NO_ROTATE}\end{overpic}
	\end{center}
	\caption{\label{fig:ExpectedPath4} Paths for the experiments rolling to a goal in $\R^2\times SO(3)$. Left,  $\left([\Delta x, \Delta y]^{\top}, \Delta R\right) = \left([0,0]^{\top},R_z(\pi)\right)$ and right $\left([2r,0]^{\top},R_x(0)\right)$.
	The path lengths are $\{314, 336   %2182.55, 325.672,314.056,335.704
	\}$mm. The start point is shown in green and the stop point in red. The $230\times125$mm workspace for our manipulator is represented by a blue rectangle.  }
\end{figure}


\item[4. Movement in $\R^2\times SO(3)$:]
Our final tests compare movement in both position and orientation.  We use two 12-segment optimized paths that respectively approximate ensemble movements of  
\begin{align*}\left([\Delta x, \Delta y]^{\top}, \Delta R\right) &= \left([0,0]^{\top},R_z(\pi)\right)\\
\text{  and  } \left([\Delta x, \Delta y]^{\top}, \Delta R\right) &=\left([2r,0]^{\top},R_x(0)\right).
\end{align*}  The desired and actual paths are shown in Fig.~\ref{fig:ExpectedPath4} and Fig.~\ref{fig:ActualPaths4}.  The path angular error is shown in Fig.~\ref{fig:pathAngularError4} and the ending angular error shown in Fig.~\ref{fig:ExpAngularError4}.

 \begin{figure}%[htb]
	\begin{center}
		\begin{overpic}[width=\columnwidth]{pathxyTurnZinplaneEns15radii.pdf}
		\scriptsize
		\put(62,55){\textcolor{red}{$\longleftarrow \qquad$\parbox{7em}{circular deviations caused by painted marker on sphere}}}
		\end{overpic}\\
		\begin{overpic}[width =\columnwidth]{pathxyENS_MOVE_2X_NO_ROTATE}\end{overpic}
	\end{center}
	\caption{\label{fig:ActualPaths4}Measured paths for rolling to a goal in $\R^2\times SO(3)$. Top,  $\left([\Delta x, \Delta y]^{\top}, \Delta R\right) = \left([0,0]^{\top},R_z(\pi)\right)$ and bottom $\left([2r,0]^{\top},R_x(0)\right)$.  The path of contact point is shown. Units are mm.
	\newline (Consistent color for each assumed radius in Figs. \ref{fig:ActualPaths4}-\ref{fig:ExpAngularError4})  }
\end{figure}

 \begin{figure}%[htb]
	\begin{center}
	        \begin{overpic}[width =\columnwidth]{pathAngErrTurnZinplaneEns15radii}
	        \put(5,26){\begin{sideways} error (rad)\end{sideways}}\end{overpic}\\
		\begin{overpic}[width=\columnwidth]{pathAngErrENS_MOVE_2X_NO_ROTATE}
		\put(5,26){\begin{sideways} error (rad)\end{sideways}}
		\put(35,-3){normalized path length}
		\end{overpic}
	\end{center}
	\caption{\label{fig:pathAngularError4}  Measured angular error as a function of path length for different assumed radii.  Top,  $\left([\Delta x, \Delta y]^{\top}, \Delta R\right) = \left([0,0]^{\top},R_z(\pi)\right)$ and bottom $\left([2r,0]^{\top},R_x(0)\right)$. 
		\newline (Consistent color for each assumed radius in Figs. \ref{fig:ActualPaths4}-\ref{fig:ExpAngularError4}) }
\end{figure}

\begin{figure}%[htb]
	\begin{center}
		\begin{overpic}[width=\columnwidth]{endAngErrTurnZinplaneEns15radii}
		\put(0,25){\begin{sideways} error (rad)\end{sideways}}
		\end{overpic}
		\begin{overpic}[width=\columnwidth]{endAngErrENS_MOVE_2X_NO_ROTATE}
		\put(0,25){\begin{sideways} error (rad)\end{sideways}}
		\put(45,-4){ radius$/\epsilon$}
		\end{overpic}
	\end{center}
	\caption{\label{fig:ExpAngularError4} Measured ending angular error for rolling to a goal in $\R^2\times SO(3)$. Top,  $\left([\Delta x, \Delta y]^{\top}, \Delta R\right) = \left([0,0]^{\top},R_z(\pi)\right)$ and bottom $\left([2r,0]^{\top},R_x(0)\right)$. 
		\newline (Consistent color for each assumed radius in Figs. \ref{fig:ActualPaths4}-\ref{fig:ExpAngularError4}) 
		}
\end{figure}

\end{description}


\section{Conclusion}\label{sec:Conclusion}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
We began with the problem of manipulating a plate-ball system where the sphere has an unknown but bounded radius. We modeled the sphere as an ensemble control system, showed that this system is ensemble controllable, and derived an approximate steering algorithm to brings the sphere to within an arbitrarily small neighborhood of any given position and orientation in $\R^2\times SO(3)$. We applied our work to manipulate spheres with unknown but bounded diameters, and validated our approach with hardware experiments that simultaneously reoriented multiple spheres.  

Our solutions consisted of open-loop paths that could be precomputed.  We demonstrated that the hardware system has low noise that was $\approx$0.04\% of commanded inputs.  This noise introduces a drift term to the state evolution that cannot be countered by open-loop control.  In many application environments it is practical to add a camera system to sense the ball orientations.  We implemented and described such a vision system in section \ref{subsec:MeasureSysPosOrient}.  

We also showed that a continuum of different-sized spheres are approximately controllable by a shared input.  Thus, a finite number of different-sized spheres are also approximately controllable by a shared input.  Using methods similar to Chapter \ref{chap:FeedbackControlDiffDrive} with differential-drive robots and  \cite{Beauchard2010a} with the Bloch system,  future work will apply feedback techniques to our plate-ball system. 

%Additionally, the classical plate-ball system is steerable in $\R^2\times SO(3)$.  Our controllability result of section \ref{sec:Controllability} used bracket motion to reorient the spheres.  These bracket motions are rotations in a square pattern on the plane, and leave the sphere $x$ and $y$ position unchanged.  Therefore we can steer from a given $[x_{start},y_{start},\Rstart]$ to a desired $[x_{goal},y_{goal},\Rgoal]\in [\R^2\times SO(3)]$.  We apply a straight line rotation to move the ensemble of spheres to $x_{goal},y_{goal}$.  This move incurs some rotation $\phi(\epsilon)$.   We finish by performing a rotation in place that approximates $\Rgoal \phi(\epsilon)^{\top} \Rstart^{\top}$. 

Finally, an important contribution of this chapter was a new experimental platform, so we provided a characterization of the system reliability and described the system so it can be replicated.  The magnetic actuation makes the mechanism easy to implement, allows an unobstructed view of the ball on the plane, and enables simultaneous manipulation of multiple balls with different radii.








